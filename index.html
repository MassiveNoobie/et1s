<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ET1</title>
    <link rel="stylesheet" href="etls.css">
    <!-- Optional Excel writer (SheetJS) for Excel Output node -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

</head>
<body>
    <div class="toolbar">
        <h1>ET1</h1>
        <button class="tool-button" onclick="createCSVNode()">📊 CSV Input</button>
        <button class="tool-button" onclick="createJSONNode()">🧾 JSON Input</button>
        <button class="tool-button" onclick="createGitHubNode()">🐙 GitHub CSV</button>
        <button class="tool-button" onclick="createManualTableNode()">📐 Manual Table</button>
        <button class="tool-button" onclick="createColumnRenamerNode()">✏️ Column Renamer</button>
        <button class="tool-button" onclick="createAnyColumnFilterNode()">🔍 Any Column Filter</button>
        <button class="tool-button" onclick="createColumnFilterNode()">📋 Column Filter</button>
        <button class="tool-button" onclick="createMeasureFilterNode()">🧮 Measure Filter</button>
        <button class="tool-button" onclick="createFindReplaceNode()">🔎 Find/Replace</button>
        <button class="tool-button" onclick="createJoinerNode()">🧷 Joiner</button>
        <button class="tool-button" onclick="createUnionNode()">🔗 Union</button>
        <button class="tool-button" onclick="createStringConcatNode()">🔗 Concat</button>
        <button class="tool-button" onclick="createStringSplitNode()">✂️ Split</button>
        <button class="tool-button" onclick="createWildHeadersNode()">🌀 Wild Headers</button>
        <button class="tool-button" onclick="createAggregationNode()">📈 Aggregate</button>
        <button class="tool-button" onclick="createRankNode()">🏁 Rank</button>
        <button class="tool-button" onclick="createConstantNode()">🔧 Constant</button>
        <button class="tool-button" onclick="createSortNode()">↕️ Sort</button>
        <button class="tool-button" onclick="createPivotNode()">📊 Pivot</button>
        <button class="tool-button" onclick="createNullValueNode()">🚫 Null</button>
        <button class="tool-button" onclick="createNormalizeNode()">🔤 Trim/Normalize</button>
        <button class="tool-button" onclick="createCSVOutputNode()">💾 CSV Output</button>
        <button class="tool-button" onclick="createJSONOutputNode()">🧾 JSON Output</button>
        <button class="tool-button" onclick="createExcelOutputNode()">📄 Excel Output</button>
    </div>
    
    <div class="canvas" id="canvas">
        <svg class="connection-canvas" id="connectionCanvas"></svg>
    </div>

    <script>
        // ===== 
        // ===== 
        // ===== 
        // ===== boring boiler plate variables =====
        // ===== 
        // ===== 
        // ===== 
        let nodes = [];
        let connections = [];
        let nodeCounter = 0;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let connectingFrom = null;
        let tempLine = null;
        let mousePos = { x: 0, y: 0 };
        // Track whether the user is dragging a connection versus clicking
        let isDraggingConnection = false;
        let dragStartPos = null;
        // Quick-add popover element reference
        let quickAddPopover = null;
        let suppressQuickAddUntil = 0; // timestamp ms to suppress click-open
        // Minimal central graph engine structures
        // Node registry and adjacency maps to avoid repeated linear scans
        const nodeById = new Map();             // id -> node
        const inNeighbors = new Map();          // id -> Set<id>
        const outNeighbors = new Map();         // id -> Set<id>
        // Dirty-queue scheduling (minimal central engine extension)
        const dirtyNodes = new Set();           // Set<nodeId>
        let recomputeTimer = null;
        const RECOMPUTE_DELAY_MS = 75;

        // Global hover lineage state: the header and value of the hovered cell
        let hoveredCell = null; // { header: string, value: string }

        function setHoveredCell(header, value) {
            hoveredCell = header ? { header, value: String(value ?? '') } : null;
            refreshHoverHighlights();
        }

        // Convert a branched compare pair into two independent lanes
        function keepBothBranches(nodeId) {
            const cp = counterpartFor(nodeId);
            if (!cp) return; // nothing to do

            // Determine which is original vs clone using our mappings
            let origId, cloneId;
            if (counterpartOf.has(nodeId)) {
                // nodeId is original
                origId = nodeId;
                cloneId = counterpartOf.get(nodeId);
            } else if (counterpartReverse.has(nodeId)) {
                // nodeId is clone
                cloneId = nodeId;
                origId = counterpartReverse.get(nodeId);
            } else {
                // Fallback: assume nodeId is original and cp is clone
                origId = nodeId;
                cloneId = cp;
            }

            // Gather downstream nodes for both lanes (including the anchors)
            const origDown = new Set(getDownstreamNodes(origId)); origDown.add(origId);
            const cloneDown = new Set(getDownstreamNodes(cloneId)); cloneDown.add(cloneId);

            // Helper to break mapping in a safe way
            function breakMap(oId, cId) {
                if (counterpartOf.has(oId)) counterpartOf.delete(oId);
                if (counterpartReverse.has(cId)) counterpartReverse.delete(cId);
            }

            // Remove pairings along both lanes
            origDown.forEach(oId => {
                const cId = counterpartOf.get(oId);
                if (cId) breakMap(oId, cId);
            });
            cloneDown.forEach(cId => {
                const oId = counterpartReverse.get(cId);
                if (oId) breakMap(oId, cId);
            });

            // Rebuild connections to clear twin-lines and refresh previews to single-grid
            updateConnections();
            // Ensure data gets recomputed so previews repopulate
            origDown.forEach(id => markDirty(id));
            cloneDown.forEach(id => markDirty(id));
            scheduleRecompute();
        }

        // ===== Branching + Diff MVP state =====
        const counterpartOf = new Map();       // origId -> cloneId
        const counterpartReverse = new Map();  // cloneId -> origId
        let branchSeq = 1;

        function setCounterparts(origId, cloneId) {
            counterpartOf.set(origId, cloneId);
            counterpartReverse.set(cloneId, origId);
        }

        function counterpartFor(id) {
            return counterpartOf.get(id) || counterpartReverse.get(id) || null;
        }

        function clearHoveredCell() {
            hoveredCell = null;
            refreshHoverHighlights();
        }

        // Add/remove CSS classes across all previews based on hoveredCell
        function refreshHoverHighlights() {
            // Clear previous
            document.querySelectorAll('.preview-table td.cell-hover').forEach(el => el.classList.remove('cell-hover'));
            document.querySelectorAll('.preview-table tr.row-hover').forEach(el => el.classList.remove('row-hover'));
            document.querySelectorAll('.preview-table th.col-hover').forEach(el => el.classList.remove('col-hover'));

            if (!hoveredCell) return;
            const { header, value } = hoveredCell;
            // Highlight headers with matching text
            document.querySelectorAll('.preview-table thead th').forEach(th => {
                if ((th.textContent || '').trim() === header) th.classList.add('col-hover');
            });
            // Highlight matching cells and their rows
            document.querySelectorAll('.preview-table tbody tr').forEach(tr => {
                const tds = Array.from(tr.children);
                for (const td of tds) {
                    const colName = td.getAttribute('data-col');
                    if (colName === header) {
                        const txt = (td.textContent || '').trim();
                        if (txt === value) {
                            td.classList.add('cell-hover');
                            tr.classList.add('row-hover');
                        }
                    }
                }
            });
        }







                                        // ===== 
                                        // ===== 
                                        // ===== 
                                        // ===== the engine =====
                                        // ===== DAG.. engine..
                                        // ===== DAG means directed acyclic graph
                                        // ===== this might be the more complex part of the code
                                        // ===== 












        function registerNode(node) {
            nodeById.set(node.id, node);
            if (!inNeighbors.has(node.id)) inNeighbors.set(node.id, new Set());
            if (!outNeighbors.has(node.id)) outNeighbors.set(node.id, new Set());
            // initialize minimal flags for future incremental updates
            if (typeof node.dirty === 'undefined') node.dirty = false;
            if (typeof node.version === 'undefined') node.version = 0;
        }
        // Helper to get all downstream nodes from a given node
        function getDownstreamNodes(nodeId) {
            const downstream = new Set();
            const visited = new Set();
            
            function traverse(currentId) {
                if (visited.has(currentId)) return;
                visited.add(currentId);
                
                const neighbors = outNeighbors.get(currentId) || new Set();
                for (const neighborId of neighbors) {
                    downstream.add(neighborId);
                    traverse(neighborId);
                }
            }
            
            traverse(nodeId);
            return downstream;
        }
        // Dirty-queue helpers - used for incremental updates
        function markDirty(startId) {
            const q = [startId];
            const seen = new Set();
            while (q.length) {
                const id = q.shift();
                if (seen.has(id)) continue;
                seen.add(id);
                const n = nodeById.get(id);
                if (!n) continue;
                n.dirty = true;
                dirtyNodes.add(id);
                const outs = outNeighbors.get(id);
                if (outs) outs.forEach(next => { if (!seen.has(next)) q.push(next); });
            }
        }
        // Schedule recompute helpers - used for incremental updates
        function scheduleRecompute() {
            if (recomputeTimer) clearTimeout(recomputeTimer);
            recomputeTimer = setTimeout(drainDirtyQueue, RECOMPUTE_DELAY_MS);
        }
        // Check if a node has any upstream data ready
        function inputsReady(nodeId) {
            // Ready if any upstream has data
            const ins = inNeighbors.get(nodeId);
            if (!ins || ins.size === 0) return false;
            for (const predId of ins) {
                const pred = nodeById.get(predId);
                if (pred && Array.isArray(pred.data) && pred.data.length >= 0 && Array.isArray(pred.headers)) {
                    // Consider ready when upstream has headers; empty data allowed
                    return true;
                }
            }
            return false;
        }
        // Compute a node if all its inputs are ready
        function computeNodeIfReady(nodeId) {
            const node = nodeById.get(nodeId);
            if (!node) return false;
            if (!inputsReady(nodeId)) return false;
            // Pick first upstream with data/headers
            const ins = inNeighbors.get(nodeId);
            for (const predId of ins) {
                const pred = nodeById.get(predId);
                if (pred && pred.headers) {
                    processNodeData(node, pred.data || [], pred.headers || []);
                    node.dirty = false;
                    dirtyNodes.delete(nodeId);
                    node.version++;
                    // Propagate to clone counterpart if this node is an original in counterpartOf
                    propagateToCounterpart(nodeId);
                    return true;
                }
            }
            return false;
        }
        // Drain dirty queue - process all dirty nodes
        function drainDirtyQueue() {
            recomputeTimer = null;
            let progressed = true;
            let guard = 0;
            while (progressed && dirtyNodes.size && guard++ < 10) {
                progressed = false;
                // Copy to avoid mutation during iteration
                const pending = Array.from(dirtyNodes);
                for (const id of pending) {
                    if (computeNodeIfReady(id)) {
                        progressed = true;
                    }
                }
            }
        }
        // Unregister a node - remove it from the graph
        function unregisterNode(nodeId) {
            // Remove adjacency edges touching nodeId
            const ins = inNeighbors.get(nodeId) || new Set();
            ins.forEach(pred => {
                const outs = outNeighbors.get(pred);
                if (outs) outs.delete(nodeId);
            });
            const outs = outNeighbors.get(nodeId) || new Set();
            outs.forEach(succ => {
                const ins2 = inNeighbors.get(succ);
                if (ins2) ins2.delete(nodeId);
            });
            inNeighbors.delete(nodeId);
            outNeighbors.delete(nodeId);
            nodeById.delete(nodeId);
            // Also remove any counterpart mapping involving this node so split previews/twin-lines don't persist
            if (counterpartOf.has(nodeId)) {
                const cloneId = counterpartOf.get(nodeId);
                counterpartOf.delete(nodeId);
                counterpartReverse.delete(cloneId);
            }
            if (counterpartReverse.has(nodeId)) {
                const origId = counterpartReverse.get(nodeId);
                counterpartReverse.delete(nodeId);
                counterpartOf.delete(origId);
            }
        }
        // DFS to detect if there is a path from start -> target
        function hasPath(startId, targetId) {
            if (startId === targetId) return true;
            const visited = new Set();
            const stack = [startId];
            while (stack.length) {
                const cur = stack.pop();
                if (cur === targetId) return true;
                if (visited.has(cur)) continue;
                visited.add(cur);
                const outs = outNeighbors.get(cur);
                if (outs) outs.forEach(n => { if (!visited.has(n)) stack.push(n); });
            }
            return false;
        }
        
        // ===== 
        // ===== 
        // ===== 
        // ===== tracking: mouse =====
        // ===== ' sticky traps work best ' 
        // ===== 
        // ===== 
        // Track mouse position for connection lines
        document.addEventListener('mousemove', (e) => {
            mousePos.x = e.clientX;
            mousePos.y = e.clientY;
            
            if (tempLine) {
                updateTempLine();
                // If the mouse moved enough, consider it a drag
                if (dragStartPos) {
                    const dx = e.clientX - dragStartPos.x;
                    const dy = e.clientY - dragStartPos.y;
                    if (!isDraggingConnection && (Math.abs(dx) + Math.abs(dy) > 4)) {
                        isDraggingConnection = true;
                    }
                }
            }
        });
       
        // ===== 
        // ===== 
        // ===== 
        // ===== node creation =====
        // ===== ' mmmhm,  the node creation'
        // ===== nodes: aggregate/joiner/... =====
        // ===== 
        // ===== 
        function createCSVNode() {
            const node = {
                id: `csv_${nodeCounter++}`,
                type: 'csv',
                x: 100 + (nodeCounter * 50),
                y: 100 + (nodeCounter * 50),
                data: null,
                headers: [],
                removeTop: 0,
                removeBottom: 0,
                expanded: false
            };
            
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
            
            // Setup CSV functionality after node is in DOM
            setupCSVNode(node.id);
        }

        function createJSONNode() {
            const node = {
                id: `json_${nodeCounter++}`,
                type: 'json',
                x: 150 + (nodeCounter * 50),
                y: 120 + (nodeCounter * 50),
                data: null,
                headers: [],
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
            // Setup JSON functionality after node is in DOM
            setupJSONNode(node.id);
        }

        function createGitHubNode() {
            const node = {
                id: `github_${nodeCounter++}`,
                type: 'github',
                x: 170 + (nodeCounter * 50),
                y: 140 + (nodeCounter * 50),
                data: null,
                headers: [],
                url: '',
                loading: false,
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createAnyColumnFilterNode() {
            const node = {
                id: `filter_${nodeCounter++}`,
                type: 'filter',
                x: 400 + (nodeCounter * 50),
                y: 100 + (nodeCounter * 50),
                pattern: '',
                caseSensitive: false,
                useRegex: true,
                mode: 'keep', // 'keep' or 'remove'
                expanded: false
            };
            
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createColumnFilterNode() {
            const node = {
                id: `columnfilter_${nodeCounter++}`,
                type: 'columnfilter',
                x: 700 + (nodeCounter * 50),
                y: 100 + (nodeCounter * 50),
                column: '',
                pattern: '',
                caseSensitive: false,
                useRegex: true,
                mode: 'keep', // 'keep' or 'remove'
                expanded: false
            };
            
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createWildHeadersNode() {
            const node = {
                id: `wildheaders_${nodeCounter++}`,
                type: 'wildheaders',
                x: 700 + (nodeCounter * 50),
                y: 100 + (nodeCounter * 50),
                pattern: '',
                caseSensitive: false,
                useRegex: true,
                mode: 'keep', // 'keep' or 'remove'
                expanded: false
            };
            
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createUnionNode() {
            const node = {
                id: `union_${nodeCounter++}`,
                type: 'union',
                x: 400 + (nodeCounter * 50),
                y: 300 + (nodeCounter * 50),
                removeDuplicates: false,
                expanded: false
            };
            
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createColumnRenamerNode() {
            const node = {
                id: `columnrenamer_${nodeCounter++}`,
                type: 'columnrenamer',
                x: 500 + (nodeCounter * 50),
                y: 200 + (nodeCounter * 50),
                renames: {},
                removals: [],
                columnOrder: [],
                movedColumns: [],
                expanded: false
            };
            
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createAggregationNode() {
            const node = {
                id: `aggregate_${nodeCounter++}`,
                type: 'aggregate',
                x: 600 + (nodeCounter * 50),
                y: 300 + (nodeCounter * 50),
                groupBy: '',
                measureCol: '',
                measureOp: 'count',
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createMeasureFilterNode() {
            const node = {
                id: `measure_${nodeCounter++}`,
                type: 'measurefilter',
                x: 700 + (nodeCounter * 50),
                y: 250 + (nodeCounter * 50),
                column: '',
                operator: '>',
                value: '',
                mode: 'keep', // 'keep' or 'remove'
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createJoinerNode() {
            const node = {
                id: `join_${nodeCounter++}`,
                type: 'joiner',
                x: 800 + (nodeCounter * 50),
                y: 220 + (nodeCounter * 50),
                leftKey: '',
                rightKey: '',
                joinType: 'inner',
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createConstantNode() {
            const node = {
                id: `constant_${nodeCounter++}`,
                type: 'constant',
                x: 750 + (nodeCounter * 50),
                y: 120 + (nodeCounter * 50),
                column: 'const',
                value: '',
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createRankNode() {
            const node = {
                id: `rank_${nodeCounter++}`,
                type: 'rank',
                x: 820 + (nodeCounter * 50),
                y: 320 + (nodeCounter * 50),
                column: '',
                order: 'desc',
                outColumn: 'rank',
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createFindReplaceNode() {
            const node = {
                id: `findreplace_${nodeCounter++}`,
                type: 'findreplace',
                x: 880 + (nodeCounter * 50),
                y: 180 + (nodeCounter * 50),
                column: '',
                pattern: '',
                replacement: '',
                caseSensitive: false,
                useRegex: true,
                wholeCell: false,
                replaceAll: true,
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createSortNode() {
            const node = {
                id: `sort_${nodeCounter++}`,
                type: 'sort',
                x: 940 + (nodeCounter * 50),
                y: 240 + (nodeCounter * 50),
                // Array of criteria: { column:'', type:'alpha'|'numeric'|'date', order:'asc'|'desc' }
                sorts: [{ column: '', type: 'alpha', order: 'asc' }],
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createStringConcatNode() {
            const node = {
                id: `stringconcat_${nodeCounter++}`,
                type: 'stringconcat',
                x: 1000 + (nodeCounter * 50),
                y: 300 + (nodeCounter * 50),
                columns: [],
                separator: '',
                outputColumn: 'concatenated',
                keepOriginal: true,
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createStringSplitNode() {
            const node = {
                id: `stringsplit_${nodeCounter++}`,
                type: 'stringsplit',
                x: 1020 + (nodeCounter * 50),
                y: 320 + (nodeCounter * 50),
                columns: [],
                delimiter: ',',
                maxSplits: 2,
                keepOriginal: true,
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createPivotNode() {
            const node = {
                id: `pivot_${nodeCounter++}`,
                type: 'pivot',
                x: 1060 + (nodeCounter * 50),
                y: 360 + (nodeCounter * 50),
                rowFields: [],
                columnField: '',
                valueField: '',
                aggregation: 'count',
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createNormalizeNode() {
            const node = {
                id: `normalize_${nodeCounter++}`,
                type: 'normalize',
                x: 1120 + (nodeCounter * 50),
                y: 260 + (nodeCounter * 50),
                columns: [],
                trimEnds: true,
                collapseSpaces: true,
                removeSpecial: false,
                caseMode: 'none', // none | lower | upper | title
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createNullValueNode() {
            const node = {
                id: `nullvalue_${nodeCounter++}`,
                type: 'nullvalue',
                x: 1160 + (nodeCounter * 50),
                y: 360 + (nodeCounter * 50),
                columns: [],
                action: 'remove', // remove, replace, keep
                replaceValue: '',
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createManualTableNode() {
            const node = {
                id: `manual_${nodeCounter++}`,
                type: 'manualtable',
                x: 200 + (nodeCounter * 50),
                y: 300 + (nodeCounter * 50),
                headers: ['Col1','Col2'],
                data: [{ 'Col1': '', 'Col2': '' }],
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
            // Render editor and initial preview
            renderManualTable(node.id);
            updateNodePreview(node.id, node.data.slice(0,5), node.headers);
        }

        function createCSVOutputNode() {
            const node = {
                id: `csvoutput_${nodeCounter++}`,
                type: 'csvoutput',
                x: 1200 + (nodeCounter * 50),
                y: 200 + (nodeCounter * 50),
                filename: 'output.csv',
                includeHeader: true,
                expanded: false
            };
            
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createJSONOutputNode() {
            const node = {
                id: `jsonoutput_${nodeCounter++}`,
                type: 'jsonoutput',
                x: 1220 + (nodeCounter * 50),
                y: 260 + (nodeCounter * 50),
                filename: 'data.json',
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }

        function createExcelOutputNode() {
            const node = {
                id: `exceloutput_${nodeCounter++}`,
                type: 'exceloutput',
                x: 1240 + (nodeCounter * 50),
                y: 320 + (nodeCounter * 50),
                filename: 'data.xlsx',
                expanded: false
            };
            const nodeElement = createNodeElement(node);
            document.getElementById('canvas').appendChild(nodeElement);
            nodes.push(node);
            registerNode(node);
        }



        // ===== 
        // ===== 
        // ===== 
        // ===== ui: controls =====
        // ===== ' yay so cool, they make the ui ' 
        // ===== 
        // ===== 
        function createNodeElement(node) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = `node ${node.type}-node`;
            nodeDiv.id = node.id;
            nodeDiv.style.left = node.x + 'px';
            nodeDiv.style.top = node.y + 'px';
            // Context menu: Branch from here
            nodeDiv.oncontextmenu = (e) => {
                e.preventDefault();
                openNodeContextMenu(node.id, e.clientX, e.clientY);
            };

            let content = '';
            
            if (node.type === 'csv') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="📊">📊 CSV Input</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div class="drop-area" id="drop_${node.id}">
                            <div>📁 Drop CSV file here</div>
                            <input type="file" accept=".csv" style="display: none;" id="file_${node.id}">
                        </div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">File Status:</label>
                            <div class="file-status" id="status_${node.id}">No file loaded</div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Remove Rows:</label>
                            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                <div style="flex: 1;">
                                    <label style="font-size: 0.8rem;">From Top:</label>
                                    <input type="number" class="setting-input" min="0" value="0" 
                                           onchange="updateCSVRowRemoval('${node.id}')" id="removeTop_${node.id}">
                                </div>
                                <div style="flex: 1;">
                                    <label style="font-size: 0.8rem;">From Bottom:</label>
                                    <input type="number" class="setting-input" min="0" value="0" 
                                           onchange="updateCSVRowRemoval('${node.id}')" id="removeBottom_${node.id}">
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (node.type === 'json') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🧾">🧾 JSON Input</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div class="drop-area" id="drop_${node.id}">
                            <div>📁 Drop JSON file here</div>
                            <input type="file" accept=".json,application/json" style="display: none;" id="file_${node.id}">
                        </div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">File Status:</label>
                            <div class="file-status" id="status_${node.id}">No file loaded</div>
                        </div>
                    </div>
                `;
            } else if (node.type === 'github') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🐙">🐙 GitHub CSV</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div class="url-input-area" id="urlArea_${node.id}">
                            <div style="margin-bottom: 8px;">🔗 GitHub CSV URL:</div>
                            <input type="url" class="setting-input" id="githubUrl_${node.id}" 
                                   placeholder="https://gist.githubusercontent.com/..." 
                                   value="${node.url}"
                                   oninput="updateGitHubUrl('${node.id}')"
                                   onchange="updateGitHubUrl('${node.id}')"
                                   onkeydown="if(event.key==='Enter'){event.preventDefault(); fetchGitHubData('${node.id}');}"
                                   style="width: 100%; margin-bottom: 8px;">
                            <button class="node-expand" onclick="event.stopPropagation(); fetchGitHubData('${node.id}')" 
                                    id="fetchBtn_${node.id}" ${node.loading ? 'disabled' : ''}>
                                ${node.loading ? '⏳ Loading...' : '📥 Fetch Data'}
                            </button>
                        </div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Status:</label>
                            <div class="file-status" id="status_${node.id}">${node.data ? `Loaded ${node.data.length} rows, ${node.headers ? node.headers.length : 0} columns` : 'No data loaded'}</div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Example URLs:</label>
                            <div class="examples">
                                • GitHub Gist raw URLs<br>
                                • Raw GitHub file URLs<br>
                                • Any public CSV endpoint
                            </div>
                        </div>
                    </div>
                `;
            } else if (node.type === 'csvoutput') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="💾">💾 CSV Output</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Export downstream data as CSV</div>
                        <div class="data-preview" id="preview_${node.id}" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Filename:</label>
                            <input type="text" class="setting-input" id="csv_name_${node.id}" placeholder="data.csv" onchange="updateCSVOutputConfig('${node.id}')">
                        </div>
                        <div class="setting-group" style="display:flex; gap:10px; align-items:center;">
                            <label class="setting-label" style="min-width:120px;">Include Header</label>
                            <input type="checkbox" id="csv_header_${node.id}" ${node.includeHeader ? 'checked' : ''} onchange="updateCSVOutputConfig('${node.id}')">
                        </div>
                        <div class="setting-group" style="display:flex; gap:10px;">
                            <button class="node-expand" onclick="event.stopPropagation(); triggerCSVExport('${node.id}')">⬇️ Export CSV</button>
                        </div>
                    </div>
                `;
            } else if (node.type === 'jsonoutput') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🧾">🧾 JSON Output</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Export downstream data as JSON</div>
                        <div class="data-preview" id="preview_${node.id}" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Filename:</label>
                            <input type="text" class="setting-input" id="json_name_${node.id}" placeholder="data.json" onchange="updateJSONOutputConfig('${node.id}')">
                        </div>
                        <div class="setting-group" style="display:flex; gap:10px;">
                            <button class="node-expand" onclick="event.stopPropagation(); triggerJSONExport('${node.id}')">⬇️ Export JSON</button>
                        </div>
                    </div>
                `;
            } else if (node.type === 'exceloutput') {
                const excelAvailable = typeof window.XLSX === 'object' && !!window.XLSX;
                const disabledAttr = excelAvailable ? '' : 'disabled title="Excel export requires SheetJS (XLSX)"';
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="📄">📄 Excel Output</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Export downstream data as Excel (.xlsx)</div>
                        <div class="data-preview" id="preview_${node.id}" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Filename:</label>
                            <input type="text" class="setting-input" id="excel_name_${node.id}" placeholder="data.xlsx" onchange="updateExcelOutputConfig('${node.id}')">
                        </div>
                        <div class="setting-group" style="display:flex; gap:10px; align-items:center;">
                            <button class="node-expand" ${disabledAttr} onclick="event.stopPropagation(); triggerExcelExport('${node.id}')">⬇️ Export Excel</button>
                            <span style="opacity:0.7; font-size:12px;">${excelAvailable ? '' : '(Excel disabled: missing XLSX library)'}</span>
                        </div>
                    </div>
                `;
            } else if (node.type === 'filter') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🔍">🔍 Any Column Filter</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Filter across all columns</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Pattern:</label>
                            <input type="text" class="setting-input" placeholder="e.g., *john* or ^id_" 
                                   onchange="updateFilterPattern('${node.id}', this.value)" />
                        </div>
                        <div class="setting-group" style="display:flex; gap:12px; align-items:center;">
                            <label class="setting-label">Mode:</label>
                            <select class="setting-select" id="afMode_${node.id}" onchange="setAnyFilterMode('${node.id}', this.value)">
                                <option value="keep" ${node.mode === 'keep' ? 'selected' : ''}>Keep matches</option>
                                <option value="remove" ${node.mode === 'remove' ? 'selected' : ''}>Remove matches</option>
                            </select>
                        </div>
                        <div class="setting-group" style="display:flex; gap:16px; align-items:center;">
                            <label><input type="checkbox" id="afCase_${node.id}" ${node.caseSensitive ? 'checked' : ''} onchange="toggleAnyFilterOption('${node.id}', 'caseSensitive', this.checked)"> Case sensitive</label>
                            <label><input type="checkbox" id="afRegex_${node.id}" ${node.useRegex ? 'checked' : ''} onchange="toggleAnyFilterOption('${node.id}', 'useRegex', this.checked)"> Use regex</label>
                        </div>
                    </div>
                `;
            } else if (node.type === 'columnfilter') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="📋">📋 Column Filter</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Filter specific column</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Column:</label>
                            <select class="setting-select" id="column_${node.id}" onchange="updateColumnFilter('${node.id}')">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Pattern:</label>
                            <input type="text" class="setting-input" placeholder="e.g., *value* or ^id_" 
                                   onchange="updateColumnFilterPattern('${node.id}', this.value)">
                        </div>
                        <div class="setting-group" style="display:flex; gap:12px; align-items:center;">
                            <label class="setting-label">Mode:</label>
                            <select class="setting-select" id="cfMode_${node.id}" onchange="setColumnFilterMode('${node.id}', this.value)">
                                <option value="keep" ${node.mode === 'keep' ? 'selected' : ''}>Keep matches</option>
                                <option value="remove" ${node.mode === 'remove' ? 'selected' : ''}>Remove matches</option>
                            </select>
                        </div>
                        <div class="setting-group" style="display:flex; gap:16px; align-items:center;">
                            <label><input type="checkbox" id="cfCase_${node.id}" ${node.caseSensitive ? 'checked' : ''} onchange="toggleColumnFilterOption('${node.id}', 'caseSensitive', this.checked)"> Case sensitive</label>
                            <label><input type="checkbox" id="cfRegex_${node.id}" ${node.useRegex ? 'checked' : ''} onchange="toggleColumnFilterOption('${node.id}', 'useRegex', this.checked)"> Use regex</label>
                        </div>
                    </div>
                `;
            } else if (node.type === 'wildheaders') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🌀">🌀 Wild Headers</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Filter columns based on header wildcard/regex</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Pattern:</label>
                            <input type="text" class="setting-input" placeholder="e.g., *name* or ^id_" 
                                   onchange="updateWildHeadersPattern('${node.id}', this.value)" />
                        </div>
                        <div class="setting-group" style="display:flex; gap:12px; align-items:center;">
                            <label class="setting-label">Mode:</label>
                            <select class="setting-select" id="whMode_${node.id}" onchange="setWildHeadersMode('${node.id}', this.value)">
                                <option value="keep" ${node.mode === 'keep' ? 'selected' : ''}>Keep matches</option>
                                <option value="remove" ${node.mode === 'remove' ? 'selected' : ''}>Remove matches</option>
                            </select>
                        </div>
                        <div class="setting-group" style="display:flex; gap:16px; align-items:center;">
                            <label><input type="checkbox" id="whCase_${node.id}" ${node.caseSensitive ? 'checked' : ''} onchange="toggleWildHeadersOption('${node.id}', 'caseSensitive', this.checked)"> Case sensitive</label>
                            <label><input type="checkbox" id="whRegex_${node.id}" ${node.useRegex ? 'checked' : ''} onchange="toggleWildHeadersOption('${node.id}', 'useRegex', this.checked)"> Use regex</label>
                        </div>
                    </div>
                `;
            } else if (node.type === 'union') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🔗">🔗 Union</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Union multiple inputs (stack rows)</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group" style="display:flex; gap:12px; align-items:center;">
                            <label><input type="checkbox" id="unionDedup_${node.id}" ${node.removeDuplicates ? 'checked' : ''} onchange="setUnionDedup('${node.id}', this.checked)"> Remove duplicates</label>
                        </div>
                    </div>
                `;
            } else if (node.type === 'columnrenamer') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="✏️">✏️ Column Renamer</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Rename/remove columns</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Column Operations:</label>
                            <div id="columnOps_${node.id}">Connect input to configure</div>
                        </div>
                    </div>
                `;
            } else if (node.type === 'aggregate') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="📈">📈 Aggregate</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Group by, aggregate, rows, KPIs</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Group By:</label>
                            <select class="setting-select" id="groupby_${node.id}" onchange="updateAggregationConfig('${node.id}')">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Measure Column (not required for count):</label>
                            <select class="setting-select" id="measureCol_${node.id}" onchange="updateAggregationConfig('${node.id}')">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Operation:</label>
                            <select class="setting-select" id="measureOp_${node.id}" onchange="updateAggregationConfig('${node.id}')">
                                <option value="count">count</option>
                                <option value="sum">sum</option>
                                <option value="avg">avg</option>
                                <option value="mean">mean</option>
                            </select>
                        </div>
                    </div>
                `;
            } else if (node.type === 'measurefilter') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🧮">🧮 Measure Filter</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Filter rows by numeric comparison</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Column:</label>
                            <select class="setting-select" id="mcol_${node.id}" onchange="updateMeasureFilterConfig('${node.id}')">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="setting-group" style="display:flex; gap:10px; align-items:center;">
                            <select class="setting-select" id="mop_${node.id}" style="max-width:100px;" onchange="updateMeasureFilterConfig('${node.id}')">
                                <option value=">">></option>
                                <option value=">=">>=</option>
                                <option value="<"><</option>
                                <option value="<="><=</option>
                                <option value="==">==</option>
                                <option value="!=">!=</option>
                            </select>
                            <input type="number" class="setting-input" id="mval_${node.id}" placeholder="Value" onchange="updateMeasureFilterConfig('${node.id}')">
                        </div>
                        <div class="setting-group" style="display:flex; gap:12px; align-items:center;">
                            <label class="setting-label">Mode:</label>
                            <select class="setting-select" id="mfMode_${node.id}" onchange="setMeasureFilterMode('${node.id}', this.value)">
                                <option value="keep" ${node.mode === 'keep' ? 'selected' : ''}>Keep matches</option>
                                <option value="remove" ${node.mode === 'remove' ? 'selected' : ''}>Remove matches</option>
                            </select>
                        </div>
                    </div>
                `;
            } else if (node.type === 'manualtable') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="📐">📐 Manual Table</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div id="manual_${node.id}"></div>
                        <div style="display:flex; gap:10px; margin-top:10px;">
                            <button class="node-expand" onclick="event.stopPropagation(); addManualRow('${node.id}')">➕ Add Row</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteManualRow('${node.id}')" style="background:#ef4444; color:white;">➖ Delete Row</button>
                        </div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Edit table headers and cells inline</label>
                        </div>
                    </div>
                `;
            } else if (node.type === 'joiner') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🧷">🧷 Joiner</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Join two inputs by keys</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Left Key:</label>
                            <input type="text" class="setting-input" id="leftKey_${node.id}" placeholder="left key" onchange="updateJoinerConfig('${node.id}')">
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Right Key:</label>
                            <input type="text" class="setting-input" id="rightKey_${node.id}" placeholder="right key" onchange="updateJoinerConfig('${node.id}')">
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Type:</label>
                            <select class="setting-select" id="joinType_${node.id}" onchange="updateJoinerConfig('${node.id}')">
                                <option value="inner">inner</option>
                                <option value="left">left</option>
                            </select>
                        </div>
                    </div>
                `;
            } else if (node.type === 'constant') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🔧">🔧 Constant</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Add a constant column to rows</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Column Name:</label>
                            <input type="text" class="setting-input" id="constCol_${node.id}" value="${node.column}" onchange="updateConstantConfig('${node.id}')">
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Value:</label>
                            <input type="text" class="setting-input" id="constVal_${node.id}" placeholder="value" onchange="updateConstantConfig('${node.id}')">
                        </div>
                    </div>
                `;
            } else if (node.type === 'rank') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🏁">🏁 Rank</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Rank rows by a numeric column</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Column:</label>
                            <select class="setting-select" id="rankCol_${node.id}" onchange="updateRankConfig('${node.id}')">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="setting-group" style="display:flex; gap:10px; align-items:center;">
                            <label class="setting-label">Order:</label>
                            <select class="setting-select" id="rankOrder_${node.id}" style="max-width:120px;" onchange="updateRankConfig('${node.id}')">
                                <option value="desc">desc</option>
                                <option value="asc">asc</option>
                            </select>
                            <input type="text" class="setting-input" id="rankOut_${node.id}" placeholder="output column" value="rank" onchange="updateRankConfig('${node.id}')">
                        </div>
                    </div>
                `;
            } else if (node.type === 'findreplace') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🔎">🔎 Find/Replace</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Find and replace in a column</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Column:</label>
                            <select class="setting-select" id="frCol_${node.id}" onchange="updateFindReplaceConfig('${node.id}')">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Find:</label>
                            <input type="text" class="setting-input" id="frFind_${node.id}" placeholder="e.g., *foo* or ^start" onchange="updateFindReplaceConfig('${node.id}')">
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Replace with:</label>
                            <input type="text" class="setting-input" id="frRepl_${node.id}" placeholder="replacement" onchange="updateFindReplaceConfig('${node.id}')">
                        </div>
                        <div class="setting-group" style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
                            <label><input type="checkbox" id="frCase_${node.id}" ${node.caseSensitive ? 'checked' : ''} onchange="updateFindReplaceConfig('${node.id}')"> Case sensitive</label>
                            <label><input type="checkbox" id="frRegex_${node.id}" ${node.useRegex ? 'checked' : ''} onchange="updateFindReplaceConfig('${node.id}')"> Use regex</label>
                            <label><input type="checkbox" id="frWhole_${node.id}" ${node.wholeCell ? 'checked' : ''} onchange="updateFindReplaceConfig('${node.id}')"> Whole cell match</label>
                            <label><input type="checkbox" id="frAll_${node.id}" ${node.replaceAll ? 'checked' : ''} onchange="updateFindReplaceConfig('${node.id}')"> Replace all</label>
                        </div>
                    </div>
                `;
            } else if (node.type === 'sort') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="↕️">↕️ Sort</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}'); renderSortCriteria('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Multi-criteria sort (alpha, numeric, date)</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div id="sortCriteria_${node.id}" class="setting-group"></div>
                        <div style="display:flex; gap:10px;">
                            <button class="node-expand" onclick="event.stopPropagation(); addSortCriterion('${node.id}')">➕ Add Sort</button>
                        </div>
                    </div>
                `;
            } else if (node.type === 'stringconcat') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🔗">🔗 Concat</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Concatenate multiple columns into one</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Columns to Concatenate:</label>
                            <div id="columnSelection_${node.id}">Connect input to configure</div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Separator:</label>
                            <input type="text" class="setting-input" id="separator_${node.id}" value="${node.separator}" placeholder="e.g., '', ',', '-'" onchange="updateStringConcatConfig('${node.id}')">
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Output Column Name:</label>
                            <input type="text" class="setting-input" id="outputColumn_${node.id}" value="${node.outputColumn}" placeholder="concatenated" onchange="updateStringConcatConfig('${node.id}')">
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="keepOriginal_${node.id}" ${node.keepOriginal ? 'checked' : ''} onchange="updateStringConcatConfig('${node.id}')">
                                Keep original columns
                            </label>
                        </div>
                    </div>
                `;
            } else if (node.type === 'stringsplit') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="✂️">✂️ Split</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Split string columns into multiple columns by delimiter</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Columns to Split:</label>
                            <div id="columnSelection_${node.id}">Connect input to configure</div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Delimiter:</label>
                            <input type="text" class="setting-input" id="delimiter_${node.id}" value="${node.delimiter}" placeholder="e.g., ',', ';', '|'" onchange="updateStringSplitConfig('${node.id}')">
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Max Splits:</label>
                            <input type="number" class="setting-input" id="maxSplits_${node.id}" value="${node.maxSplits}" min="1" max="10" onchange="updateStringSplitConfig('${node.id}')">
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="keepOriginal_${node.id}" ${node.keepOriginal ? 'checked' : ''} onchange="updateStringSplitConfig('${node.id}')">
                                Keep original columns
                            </label>
                        </div>
                    </div>
                `;
            } else if (node.type === 'normalize') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🔤">🔤 Trim/Normalize</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Trim whitespace and normalize case in selected columns</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Columns to Normalize:</label>
                            <div id="columnSelection_${node.id}">Connect input to configure</div>
                        </div>
                        <div class="setting-group" style="display:flex; gap:10px; align-items:center; flex-wrap: wrap;">
                            <label class="setting-label"><input type="checkbox" id="trimEnds_${node.id}" ${node.trimEnds ? 'checked' : ''} onchange="updateNormalizeConfig('${node.id}')"> Trim ends</label>
                            <label class="setting-label"><input type="checkbox" id="collapseSpaces_${node.id}" ${node.collapseSpaces ? 'checked' : ''} onchange="updateNormalizeConfig('${node.id}')"> Whitespace</label>
                            <label class="setting-label"><input type="checkbox" id="removeSpecial_${node.id}" ${node.removeSpecial ? 'checked' : ''} onchange="updateNormalizeConfig('${node.id}')"> SpecialChar</label>
                            <br style="flex-basis: 100%; height: 0;">
                            <label class="setting-label">Case:</label>
                            <select class="setting-select" id="caseMode_${node.id}" style="max-width:140px;" onchange="updateNormalizeConfig('${node.id}')">
                                <option value="none" ${node.caseMode==='none'?'selected':''}>none</option>
                                <option value="lower" ${node.caseMode==='lower'?'selected':''}>lower</option>
                                <option value="upper" ${node.caseMode==='upper'?'selected':''}>upper</option>
                                <option value="title" ${node.caseMode==='title'?'selected':''}>title</option>
                            </select>
                        </div>
                    </div>
                `;
            } else if (node.type === 'nullvalue') {
                content = `
                    <div class="node-header">
                        <span class="node-title">🚫 Null</span>
                        <div class="node-controls">
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Handle null/empty values in columns</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Columns to Process:</label>
                            <div id="columnSelection_${node.id}">Connect input to configure</div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Action:</label>
                            <select class="setting-select" id="action_${node.id}" onchange="updateNullValueConfig('${node.id}')">
                                <option value="remove">Remove rows with nulls</option>
                                <option value="replace">Replace nulls with value</option>
                                <option value="keep">Keep nulls as-is</option>
                            </select>
                        </div>
                        <div class="setting-group" id="replaceValueGroup_${node.id}" style="display: none;">
                            <label class="setting-label">Replace Value:</label>
                            <input type="text" class="setting-input" id="replaceValue_${node.id}" 
                                   placeholder="Enter replacement value" onchange="updateNullValueConfig('${node.id}')">
                        </div>
                    </div>
                `;
            } else if (node.type === 'pivot') {
                content = `
                    <div class="node-header">
                        <div class="node-title" data-emoji="🔄">🔄 Pivot</div>
                        <div>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeCollapse('${node.id}')" style="margin-right: 5px;">📦</button>
                            <button class="node-expand" onclick="event.stopPropagation(); deleteNode('${node.id}')" style="background: #ef4444; margin-right: 5px;">🗑️</button>
                            <button class="node-expand" onclick="event.stopPropagation(); toggleNodeSettings('${node.id}')">⚙️</button>
                        </div>
                    </div>
                    <div class="node-content">
                        <div>Transform rows to columns (pivot table)</div>
                        <div class="data-preview" id="preview_${node.id}" style="display: none;" ondblclick="toggleDataView('${node.id}')"></div>
                    </div>
                    <div class="node-settings" id="settings_${node.id}">
                        <div class="setting-group">
                            <label class="setting-label">Row Fields (Group By):</label>
                            <div id="rowFieldSelection_${node.id}">Connect input to configure</div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Column Field:</label>
                            <select class="setting-select" id="columnField_${node.id}" onchange="updatePivotConfig('${node.id}')">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Value Field:</label>
                            <select class="setting-select" id="valueField_${node.id}" onchange="updatePivotConfig('${node.id}')">
                                <option value="">Select column...</option>
                            </select>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Aggregation:</label>
                            <select class="setting-select" id="aggregation_${node.id}" onchange="updatePivotConfig('${node.id}')">
                                <option value="count">count</option>
                                <option value="sum">sum</option>
                                <option value="avg">avg</option>
                                <option value="min">min</option>
                                <option value="max">max</option>
                            </select>
                        </div>
                    </div>
                `;
            }

            // Add connection points based on node type
            let connectionPoints = '';
            if (node.type !== 'csv' && node.type !== 'json' && node.type !== 'manualtable' && node.type !== 'github') {
                // Inputs are receive-only; no drag start handler
                connectionPoints += `<div class="connection-point input"></div>`;
            }
            if (node.type !== 'csvoutput' && node.type !== 'jsonoutput' && node.type !== 'exceloutput') {
                connectionPoints += `<div class="connection-point output" onmousedown="startConnection(event, '${node.id}', 'output')"></div>`;
            }
            
            nodeDiv.innerHTML = content + connectionPoints;

            // Add drag functionality
            const header = nodeDiv.querySelector('.node-header');
            header.addEventListener('mousedown', (e) => startDrag(e, node.id));

            return nodeDiv;
        }

        function setupCSVNode(nodeId) {
            const dropArea = document.getElementById(`drop_${nodeId}`);
            const fileInput = document.getElementById(`file_${nodeId}`);

            dropArea.addEventListener('click', () => fileInput.click());
            
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.classList.add('dragover');
            });

            dropArea.addEventListener('dragleave', () => {
                dropArea.classList.remove('dragover');
            });

            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].name.endsWith('.csv')) {
                    handleCSVFile(files[0], nodeId);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleCSVFile(e.target.files[0], nodeId);
                }
            });
        }

        function setupJSONNode(nodeId) {
            const dropArea = document.getElementById(`drop_${nodeId}`);
            const fileInput = document.getElementById(`file_${nodeId}`);

            dropArea.addEventListener('click', () => fileInput.click());

            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.classList.add('dragover');
            });

            dropArea.addEventListener('dragleave', () => {
                dropArea.classList.remove('dragover');
            });

            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.classList.remove('dragover');

                const files = e.dataTransfer.files;
                if (files.length > 0 && (files[0].name.endsWith('.json') || files[0].type === 'application/json')) {
                    handleJSONFile(files[0], nodeId);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleJSONFile(e.target.files[0], nodeId);
                }
            });
        }

        function handleCSVFile(file, nodeId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const csv = e.target.result;
                const lines = csv.trim().split('\n');
                const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                    if (values.length === headers.length) {
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index];
                        });
                        data.push(row);
                    }
                }

                // Update node data
                const node = nodes.find(n => n.id === nodeId);
                node.data = data;
                node.headers = headers;

                // Process CSV data with row removal
                processCSVData(node);

                // Update UI
                document.getElementById(`status_${nodeId}`).textContent = 
                    `${file.name} - ${data.length} records`;

                // Update connected nodes (enqueue downstream)
                markDirty(nodeId);
                scheduleRecompute();
                // Also immediately try to render direct downstream previews
                const outs = outNeighbors.get(nodeId);
                if (outs && outs.size) {
                    outs.forEach(succId => {
                        if (inputsReady(succId)) {
                            computeNodeIfReady(succId);
                        } else {
                            const succ = nodeById.get(succId);
                            if (succ && (succ.type === 'findreplace' || succ.type === 'joiner')) {
                                processNodeData(succ, node.data || [], node.headers || []);
                            }
                        }
                    });
                }
            };
            reader.readAsText(file);
        }

        function handleJSONFile(file, nodeId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                let parsed;
                try {
                    parsed = JSON.parse(e.target.result);
                } catch (err) {
                    console.error('Invalid JSON:', err);
                    alert('Invalid JSON file.');
                    return;
                }

                // Support common shapes: Array<object> or { data: Array<object> }
                let rows = [];
                if (Array.isArray(parsed)) {
                    rows = parsed;
                } else if (parsed && Array.isArray(parsed.data)) {
                    rows = parsed.data;
                } else {
                    // Single object -> wrap
                    rows = [parsed];
                }
                // Ensure objects
                rows = rows.map(r => (r && typeof r === 'object') ? r : { value: r });

                // Derive headers from first row
                const headers = rows.length ? Object.keys(rows[0]) : [];

                const node = nodes.find(n => n.id === nodeId);
                node.data = rows;
                node.headers = headers;

                // Render preview
                updateNodePreview(node.id, rows.slice(0,5), headers);

                // Update UI status
                const statusEl = document.getElementById(`status_${nodeId}`);
                if (statusEl) statusEl.textContent = `${file.name} - ${rows.length} records`;

                // Propagate
                markDirty(nodeId);
                scheduleRecompute();
                const outs = outNeighbors.get(nodeId);
                if (outs && outs.size) {
                    outs.forEach(succId => {
                        if (inputsReady(succId)) {
                            computeNodeIfReady(succId);
                        } else {
                            const succ = nodeById.get(succId);
                            if (succ && (succ.type === 'findreplace' || succ.type === 'joiner' || succ.type === 'csvoutput' || succ.type === 'jsonoutput' || succ.type === 'exceloutput')) {
                                processNodeData(succ, node.data || [], node.headers || []);
                            }
                        }
                    });
                }
            };
            reader.readAsText(file);
        }

        function updateNodePreview(nodeId, data, headers) {
            const preview = document.getElementById(`preview_${nodeId}`);
            
            if (!data || data.length === 0) {
                preview.style.display = 'none';
                return;
            }

            // If headers are missing, infer from the first record so grid renders
            let hdrs = Array.isArray(headers) && headers.length ? headers : Object.keys(data[0] || {});
            // If this node has a counterpart with data, render split preview instead
            const cpId = counterpartFor(nodeId);
            if (cpId) {
                const cp = nodeById.get(cpId);
                if (cp && Array.isArray(cp.headers) && cp.headers.length) {
                    preview.innerHTML = renderSplitPreview(nodeId, hdrs, data, cpId, cp.headers, cp.data || []);
                    preview.style.display = 'block';
                    // Attach hover listeners for lineage on both tables inside the split
                    preview.onmouseover = (ev) => {
                        const td = ev.target && ev.target.closest('td');
                        if (!td || !preview.contains(td)) return;
                        const col = td.getAttribute('data-col');
                        if (!col) return;
                        setHoveredCell(col, (td.textContent || '').trim());
                    };
                    preview.onmouseleave = () => { clearHoveredCell(); };
                    refreshHoverHighlights();
                    updateConnections();
                    return;
                }
            }
            // Determine impacted columns for subtle highlighting
            const node = nodeById.get(nodeId) || nodes.find(n => n.id === nodeId) || {};
            const impactedColsArr = (node.impact && Array.isArray(node.impact.columns)) ? node.impact.columns : [];
            const impactedCols = new Set(impactedColsArr);

            let tableHTML = '<table class="preview-table"><thead><tr>';
            hdrs.forEach(header => {
                const thCls = impactedCols.has(header) ? ' class="col-impacted"' : '';
                tableHTML += `<th${thCls}>${header}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            // Show only top 5 rows in single-grid preview for consistency
            const sampleRows = (data || []).slice(0, 5);
            sampleRows.forEach(record => {
                // Row-level highlighting support (e.g., Union secondary inputs)
                const rowCls = (record && typeof record.__unionFromIdx === 'number' && record.__unionFromIdx > 0)
                    ? ' class="row-union-secondary"' : '';
                tableHTML += `<tr${rowCls}>`;
                hdrs.forEach(header => {
                    const tdCls = impactedCols.has(header) ? ' class="cell-impacted"' : '';
                    // Add data-col for cross-node hover lineage matching
                    const cellVal = record[header] ?? '';
                    tableHTML += `<td${tdCls} data-col="${header}">${cellVal}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody></table>';
            preview.innerHTML = tableHTML;
            preview.style.display = 'block';

            // Attach minimal hover listeners (delegated) to set global hoveredCell
            // Avoid adding multiple identical listeners: clear any existing by resetting handlers
            preview.onmouseover = (ev) => {
                const td = ev.target && ev.target.closest('td');
                if (!td || !preview.contains(td)) return;
                const col = td.getAttribute('data-col');
                if (!col) return;
                setHoveredCell(col, (td.textContent || '').trim());
            };
            preview.onmouseleave = () => { clearHoveredCell(); };

            // Refresh highlights in case a hover was active before this render
            refreshHoverHighlights();
            
            // Update connections when data grid appears/changes size
            updateConnections();
            // Add a small delay to ensure DOM has fully updated
            //setTimeout(() => updateConnections(), 1000);
        }

        // Render a side-by-side split preview with simple stats/badges and Top-5 rows
        function renderSplitPreview(leftId, leftHeaders, leftData, rightId, rightHeaders, rightData) {
            const leftRows = (leftData || []).slice(0, 5);
            const rightRows = (rightData || []).slice(0, 5);
            // Schema badge if header sets differ
            const sameSchema = JSON.stringify(leftHeaders) === JSON.stringify(rightHeaders);
            const common = sameSchema ? leftHeaders.slice() : leftHeaders.filter(h => rightHeaders.includes(h));

            function tableHTML(headers, rows, side) {
                let html = `<div class="split-side ${side}">`;
                html += `<div class="split-badges"><span class="badge badge-rows">Rows: ${(rows.length)}/${(side==='left'? (leftData||[]).length : (rightData||[]).length)}</span>`;
                if (!sameSchema && side==='left') html += `<span class="badge badge-schema">Schema differs</span>`;
                html += `</div>`;
                html += '<table class="preview-table"><thead><tr>';
                const hdrsToShow = common.length ? common : headers;
                hdrsToShow.forEach(h => { html += `<th>${h}</th>`; });
                html += '</tr></thead><tbody>';
                rows.forEach((row, rIdx) => {
                    html += '<tr>';
                    hdrsToShow.forEach(h => {
                        const val = row ? (row[h] ?? '') : '';
                        html += `<td data-col="${h}" data-r="${rIdx}">${val}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table></div>';
                return html;
            }

            // Compose two tables
            let out = '<div class="split-preview">';
            out += tableHTML(leftHeaders, leftRows, 'left');
            out += tableHTML(rightHeaders, rightRows, 'right');
            out += '</div>';

            // After HTML generation, mark diffs via DOM once inserted by caller
            // The caller simply sets innerHTML and we rely on CSS. We'll also compute diffs here by returning inline script? Instead, caller calls refreshHighlights; but for diffs we can mark after insertion.
            // We will mark diffs on next microtask using a setTimeout 0 once the DOM exists.
            setTimeout(() => {
                const preview = document.getElementById(`preview_${leftId}`);
                if (!preview) return;
                const leftTable = preview.querySelector('.split-side.left table');
                const rightTable = preview.querySelector('.split-side.right table');
                if (!leftTable || !rightTable) return;
                const rows = Math.max(leftRows.length, rightRows.length);
                for (let r = 0; r < rows; r++) {
                    common.forEach(h => {
                        const ltd = leftTable.querySelector(`tbody tr:nth-child(${r+1}) td[data-col="${h}"]`);
                        const rtd = rightTable.querySelector(`tbody tr:nth-child(${r+1}) td[data-col="${h}"]`);
                        if (!ltd || !rtd) return;
                        const lv = (ltd.textContent || '').trim();
                        const rv = (rtd.textContent || '').trim();
                        if (lv !== rv) {
                            ltd.classList.add('cell-diff');
                            rtd.classList.add('cell-diff');
                            // mark row as having differences
                            const ltr = ltd.parentElement; const rtr = rtd.parentElement;
                            ltr && ltr.classList.add('row-diff');
                            rtr && rtr.classList.add('row-diff');
                        }
                    });
                }
            }, 0);

            return out;
        }

        // Simple node context menu for branching
        let nodeCtxMenu = null;
        function openNodeContextMenu(nodeId, x, y) {
            closeNodeContextMenu();
            const menu = document.createElement('div');
            menu.className = 'node-ctx-menu';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            // Base action
            let html = `<div class="node-ctx-item" data-act="branch">🌿 Branch from here</div>`;
            // If this node participates in a branch pairing, offer promotion and keep-both
            const hasCp = !!counterpartFor(nodeId);
            if (hasCp) {
                html += `<div class="node-ctx-item" data-act="promote">🏆 Promote this branch</div>`;
                html += `<div class="node-ctx-item" data-act="keepboth">🤝 Keep both (no compare)</div>`;
            }
            menu.innerHTML = html;
            menu.addEventListener('click', (e) => {
                const act = e.target && e.target.getAttribute('data-act');
                if (act === 'branch') {
                    branchFromNode(nodeId);
                    closeNodeContextMenu();
                } else if (act === 'promote') {
                    promoteBranch(nodeId);
                    closeNodeContextMenu();
                } else if (act === 'keepboth') {
                    keepBothBranches(nodeId);
                    closeNodeContextMenu();
                }
            });
            document.body.appendChild(menu);
            nodeCtxMenu = menu;
            setTimeout(() => {
                function outside(ev) {
                    if (!nodeCtxMenu) return;
                    if (!nodeCtxMenu.contains(ev.target)) {
                        closeNodeContextMenu();
                        document.removeEventListener('mousedown', outside, true);
                    }
                }
                document.addEventListener('mousedown', outside, true);
            }, 0);
        }
        function closeNodeContextMenu() {
            if (nodeCtxMenu && nodeCtxMenu.parentNode) nodeCtxMenu.parentNode.removeChild(nodeCtxMenu);
            nodeCtxMenu = null;
        }

        // Promote the branch of the given node: keep this lane, remove the opposite lane
        function promoteBranch(nodeId) {
            const cpId = counterpartFor(nodeId);
            if (!cpId) return; // not in a branched pair

            // Determine original anchor (the original lane node at/above the clicked point)
            // If clicked node is a clone, find its original counterpart id
            const isOriginal = counterpartOf.has(nodeId);
            const isClone = counterpartReverse.has(nodeId);
            const anchorOrigId = isClone ? counterpartReverse.get(nodeId) : (isOriginal ? nodeId : null);
            if (!anchorOrigId) return;

            // Compute downstream original ids including the anchor
            const ds = new Set(getDownstreamNodes(anchorOrigId));
            ds.add(anchorOrigId);

            // Snapshot counterpart mapping for this downstream region
            const origToClone = new Map();
            ds.forEach(oid => {
                const cid = counterpartOf.get(oid);
                if (cid) origToClone.set(oid, cid);
            });

            // Determine kept and deleted ids based on which lane wins
            const deleteIds = [];
            const keepIds = new Set();
            if (isOriginal) {
                // Keep all originals in region
                ds.forEach(oid => keepIds.add(oid));
                // Delete their clones
                origToClone.forEach(cid => deleteIds.push(cid));
            } else {
                // Keep clones corresponding to originals in region
                origToClone.forEach((cid) => keepIds.add(cid));
                // Delete the originals in region
                origToClone.forEach((cid, oid) => deleteIds.push(oid));
            }

            // Remove duplicates and perform deletions
            const unique = Array.from(new Set(deleteIds));
            // Delete deeper nodes first isn't strictly necessary as deleteNode handles maps/edges; simple order is fine
            unique.forEach(id => deleteNode(id));

            // Clear any remaining counterpart mappings touching this region and kept ids
            ds.forEach(oid => {
                const cid = counterpartOf.get(oid);
                if (cid) { counterpartOf.delete(oid); counterpartReverse.delete(cid); }
            });
            // also clear reverse side safety
            origToClone.forEach((cid, oid) => {
                if (counterpartReverse.get(cid) === oid) counterpartReverse.delete(cid);
            });

            // Refresh UI: connections and previews, and force recompute for kept lane so grids persist
            updateConnections();
            keepIds.forEach(id => { markDirty(id); });
            scheduleRecompute();
            // Also immediately update previews for responsiveness (will be overwritten by recompute results)
            keepIds.forEach(id => {
                const n = nodeById.get(id);
                if (n) updateNodePreview(id, n.data || [], n.headers || []);
            });
        }

        // Clone downstream subgraph into a right-side lane and set counterparts
        function branchFromNode(startId) {
            const ds = Array.from(getDownstreamNodes(startId));
            if (ds.length === 0) return; // nothing to branch
            const suffix = `_b${branchSeq++}`;

            // Build a set for quick lookup
            const dsSet = new Set(ds);
            // Include first-level successors of startId that are in ds
            const clones = new Map(); // oldId -> newNode

            // Compute depth from startId for nodes inside the downstream subgraph
            // Direct children of startId have depth 1, their children depth 2, etc.
            const depth = new Map();
            const queue = [];
            connections.forEach(conn => {
                if (conn.from === startId && dsSet.has(conn.to)) {
                    depth.set(conn.to, 1);
                    queue.push(conn.to);
                }
            });
            while (queue.length) {
                const cur = queue.shift();
                const curD = depth.get(cur) || 1;
                connections.forEach(conn => {
                    if (conn.from === cur && dsSet.has(conn.to)) {
                        const nextD = curD + 1;
                        if (!depth.has(conn.to) || depth.get(conn.to) < nextD) {
                            depth.set(conn.to, nextD);
                            queue.push(conn.to);
                        }
                    }
                });
            }

            // 1) Clone nodes (we will position them later as a horizontal lane)
            ds.forEach(oldId => {
                const old = nodeById.get(oldId);
                if (!old) return;
                const newNode = JSON.parse(JSON.stringify(old));
                newNode.id = old.id + suffix;
                // Start with temp positions; final layout computed below
                newNode.x = (old.x || 0);
                newNode.y = (old.y || 0);
                // Ensure settings are open/expanded for visibility in the branch lane
                newNode.expanded = true;
                newNode.data = null; // force recompute
                // Register and add to DOM
                const el = createNodeElement(newNode);
                document.getElementById('canvas').appendChild(el);
                // Open settings panel in the DOM
                const settingsEl = document.getElementById(`settings_${newNode.id}`);
                if (settingsEl && !settingsEl.classList.contains('active')) settingsEl.classList.add('active');
                nodes.push(newNode);
                registerNode(newNode);
                clones.set(oldId, newNode);
                setCounterparts(oldId, newNode.id);
            });

            // 2) Clone internal connections and add branch edge from startId to cloned children
            connections.forEach(conn => {
                if (dsSet.has(conn.from) && dsSet.has(conn.to)) {
                    // internal connection -> map to clones
                    const fromClone = clones.get(conn.from);
                    const toClone = clones.get(conn.to);
                    if (fromClone && toClone) {
                        createConnection(fromClone.id, conn.fromType, toClone.id, conn.toType);
                    }
                }
            });
            // Add edges from startId to cloned immediate children that were originally fed by startId
            connections.forEach(conn => {
                if (conn.from === startId && dsSet.has(conn.to)) {
                    const toClone = clones.get(conn.to);
                    if (toClone) createConnection(startId, conn.fromType, toClone.id, conn.toType);
                }
            });

            // 3) Layout clones as a single horizontal lane under the lowest original node in this region
            // Find baseline Y just below the lowest original node bottom
            let lowestBottom = 0;
            ds.forEach(oid => {
                const origEl = document.getElementById(oid);
                if (origEl) {
                    const h = origEl.getBoundingClientRect().height;
                    const top = parseInt(origEl.style.top) || 0;
                    lowestBottom = Math.max(lowestBottom, top + h);
                }
            });
            const BASE_GAP_Y = 40; // gap below lowest original
            const laneY = lowestBottom + BASE_GAP_Y;

            // Build an ordered list of clones. Anchor should be the first downstream node (depth=1) with smallest x.
            const items = Array.from(clones.entries()).map(([oid, cnode]) => ({
                oid,
                cnode,
                d: depth.get(oid) || 1,
                ox: (nodeById.get(oid) && nodeById.get(oid).x) || 0
            }));
            const depth1 = items.filter(it => it.d === 1);
            let anchor = null;
            if (depth1.length) {
                anchor = depth1.reduce((min, it) => (min === null || it.ox < min.ox) ? it : min, null);
            }
            // Sort others by depth then x
            const others = items
                .filter(it => !anchor || it.oid !== anchor.oid)
                .sort((a, b) => (a.d - b.d) || (a.ox - b.ox));
            const ordered = anchor ? [anchor, ...others] : others;

            // Start x under the anchor (first downstream) if available, else fallback to previous logic
            let cursorX = anchor ? anchor.ox : (items.length ? items.sort((a,b)=>a.ox-b.ox)[0].ox : 0);
            const H_GAP = 60; // horizontal spacing between nodes

            ordered.forEach((item, idx) => {
                const el = document.getElementById(item.cnode.id);
                if (!el) return;
                // Measure width for non-overlap placement
                const w = el.getBoundingClientRect().width || 280;
                // Position element
                item.cnode.x = cursorX;
                item.cnode.y = laneY;
                el.style.left = item.cnode.x + 'px';
                el.style.top = item.cnode.y + 'px';
                // Advance cursor for next item
                cursorX += w + H_GAP;
            });

            // 3b) Align originals (top lane) with their clone counterparts by centering horizontally
            ds.forEach(oid => {
                const orig = nodeById.get(oid);
                const clone = clones.get(oid);
                const origEl = document.getElementById(oid);
                const cloneEl = clone ? document.getElementById(clone.id) : null;
                if (!orig || !origEl || !clone || !cloneEl) return;
                const ow = origEl.getBoundingClientRect().width || 280;
                const cw = cloneEl.getBoundingClientRect().width || 280;
                const targetCenter = clone.x + cw / 2;
                const newX = Math.round(targetCenter - ow / 2);
                // animate subtle slide to position
                origEl.style.transition = 'left 350ms ease-in-out, top 350ms ease-in-out';
                orig.x = newX;
                origEl.style.left = newX + 'px';
            });

            updateConnections();
            // ensure connections settle after animation completes
            setTimeout(() => updateConnections(), 380);
            // Mark cloned heads dirty so they compute
            ds.forEach(id => { const n = clones.get(id); if (n) markDirty(n.id); });
            scheduleRecompute();
        }

        // One-way propagation: original -> clone
        function propagateToCounterpart(nodeId) {
            // Only propagate if this node is an original that has a registered clone
            if (!counterpartOf.has(nodeId)) return;
            const cloneId = counterpartOf.get(nodeId);
            if (!cloneId) return;
            // Mark clone and its downstream as dirty to recompute with latest source data
            markDirty(cloneId);
            scheduleRecompute();
        }

        function toggleNodeSettings(nodeId) {
            const settings = document.getElementById(`settings_${nodeId}`);
            const node = nodes.find(n => n.id === nodeId);
            
            if (settings.classList.contains('active')) {
                settings.classList.remove('active');
                node.expanded = false;
            } else {
                settings.classList.add('active');
                node.expanded = true;
            }
            updateConnections();
        }

        function toggleNodeCollapse(nodeId) {
            const nodeElement = document.getElementById(nodeId);
            const node = nodes.find(n => n.id === nodeId);
            
            node.collapsed = !node.collapsed;
            nodeElement.classList.toggle('collapsed');
            
            // Add/remove click handler for collapsed state
            if (node.collapsed) {
                nodeElement.addEventListener('click', handleCollapsedNodeClick);
            } else {
                nodeElement.removeEventListener('click', handleCollapsedNodeClick);
            }
            
            // Update connections after collapse/expand
          //  updateConnections();
            // Add a small delay to ensure DOM has fully updated
            setTimeout(() => updateConnections(), 400);
        }

        function handleCollapsedNodeClick(e) {
            // Prevent if clicking on connection points or buttons
            if (e.target.classList.contains('connection-point') || 
                e.target.classList.contains('node-expand') ||
                e.target.tagName === 'BUTTON') {
                return;
            }
            
            const nodeId = e.currentTarget.id;
            toggleNodeCollapse(nodeId);
        }
        
        function deleteNode(nodeId) {
            // Mark all downstream nodes as dirty before deletion
            const downstreamNodes = getDownstreamNodes(nodeId);
            downstreamNodes.forEach(id => markDirty(id));

            // If this node participates in a branch counterpart mapping, clear it and refresh the surviving node's preview
            const cpId = counterpartFor(nodeId);
            if (cpId) {
                if (counterpartOf.has(nodeId)) {
                    // nodeId is original
                    counterpartReverse.delete(counterpartOf.get(nodeId));
                    counterpartOf.delete(nodeId);
                } else if (counterpartReverse.has(nodeId)) {
                    // nodeId is clone
                    counterpartOf.delete(counterpartReverse.get(nodeId));
                    counterpartReverse.delete(nodeId);
                }
            }

            // Remove the DOM element
            const el = document.getElementById(nodeId);
            if (el && el.parentElement) {
                el.parentElement.removeChild(el);
            }
            
            // Remove from nodes array
            nodes = nodes.filter(n => n.id !== nodeId);
            
            // Remove any connections related to this node
            connections = connections.filter(conn => conn.from !== nodeId && conn.to !== nodeId);
            // Update adjacency maps
            unregisterNode(nodeId);
            
            // Redraw connections
            updateConnections();
            
            // Trigger recompute for affected downstream nodes
            if (downstreamNodes.size > 0) {
                scheduleRecompute();
            }

            // If there was a counterpart, re-render its preview in single-grid mode
            if (cpId) {
                const cpNode = nodeById.get(cpId) || nodes.find(n => n.id === cpId);
                if (cpNode) {
                    updateNodePreview(cpId, cpNode.data || [], cpNode.headers || []);
                }
            }
        }

        function startDrag(e, nodeId) {
            e.preventDefault();
            draggedNode = nodeId;
            const nodeElement = document.getElementById(nodeId);
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate offset relative to canvas, not viewport
            dragOffset.x = e.clientX - canvasRect.left - parseInt(nodeElement.style.left);
            dragOffset.y = e.clientY - canvasRect.top - parseInt(nodeElement.style.top);

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
        }

        function drag(e) {
            if (!draggedNode) return;
            
            const nodeElement = document.getElementById(draggedNode);
            const node = nodes.find(n => n.id === draggedNode);
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate position relative to canvas
            node.x = e.clientX - canvasRect.left - dragOffset.x;
            node.y = e.clientY - canvasRect.top - dragOffset.y;
            
            nodeElement.style.left = node.x + 'px';
            nodeElement.style.top = node.y + 'px';
            
            updateConnections();
        }

        function stopDrag() {
            draggedNode = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }

        function startConnection(e, nodeId, type) {
            e.preventDefault();
            e.stopPropagation();
            // Inputs cannot initiate connections; only outputs can send
            if (type !== 'output') return;
            
            // Prepare drag detection
            isDraggingConnection = false;
            dragStartPos = { x: e.clientX, y: e.clientY };

            connectingFrom = { nodeId, type };
            
            // Create temporary line
            const svg = document.getElementById('connectionCanvas');
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempLine.classList.add('temp-line');
            svg.appendChild(tempLine);
            
            document.addEventListener('mousemove', updateTempLine);
            document.addEventListener('mouseup', endConnection);
        }

        function updateTempLine() {
            if (!tempLine || !connectingFrom) return;
            
            const fromNode = document.getElementById(connectingFrom.nodeId);
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Get node position relative to canvas
            const fromX = parseInt(fromNode.style.left) || 0;
            const fromY = parseInt(fromNode.style.top) || 0;
            const fromRect = fromNode.getBoundingClientRect();
            
            let startX, startY;
            if (connectingFrom.type === 'output') {
                startX = fromX + fromRect.width;
                startY = fromY + fromRect.height / 2;
            } else {
                startX = fromX;
                startY = fromY + fromRect.height / 2;
            }
            
            // Convert mouse position to canvas coordinates
            const mouseCanvasX = mousePos.x - canvasRect.left;
            const mouseCanvasY = mousePos.y - canvasRect.top;
            
            const path = `M ${startX} ${startY} Q ${(startX + mouseCanvasX) / 2} ${startY} ${mouseCanvasX} ${mouseCanvasY}`;
            tempLine.setAttribute('d', path);
        }

        function endConnection(e) {
            // Decide whether to keep the temp line (when opening quick-add)
            let keepTemp = false;
            // Reset drag state after mouse up, but if we were dragging, suppress immediate click
            const wasDragging = isDraggingConnection;
            isDraggingConnection = false;
            dragStartPos = null;
            
            // Check if we're over a connection point
            const target = e.target;
            if (target.classList.contains('connection-point') && connectingFrom) {
                const targetNodeId = target.parentElement.id;
                const targetType = target.classList.contains('input') ? 'input' : 'output';
                
                // Can't connect to same node or same type
                if (targetNodeId !== connectingFrom.nodeId && 
                    targetType !== connectingFrom.type) {
                    createConnection(connectingFrom.nodeId, connectingFrom.type, targetNodeId, targetType);
                }
            } else if (connectingFrom && connectingFrom.type === 'output') {
                // Try to magnet to nearest input if close or inside a node with an input
                const canvas = document.getElementById('canvas');
                const canvasRect = canvas.getBoundingClientRect();
                const mouseX = mousePos.x - canvasRect.left;
                const mouseY = mousePos.y - canvasRect.top;

                let chosenNodeId = null;
                let minDist = Infinity;
                const threshold = 48; // px radius to snap

                // 1) Check explicit input connection points
                const inputs = Array.from(document.querySelectorAll('.connection-point.input'));
                inputs.forEach(inp => {
                    const rect = inp.getBoundingClientRect();
                    const cx = (rect.left + rect.right) / 2 - canvasRect.left;
                    const cy = (rect.top + rect.bottom) / 2 - canvasRect.top;
                    const dx = cx - mouseX;
                    const dy = cy - mouseY;
                    const d = Math.hypot(dx, dy);
                    const nodeId = inp.parentElement && inp.parentElement.id;
                    if (nodeId && nodeId !== connectingFrom.nodeId && d < minDist) {
                        minDist = d;
                        chosenNodeId = nodeId;
                    }
                });

                // 2) If not within threshold, see if cursor is over any node that has an input
                if (!(minDist <= threshold)) {
                    const el = document.elementFromPoint(e.clientX, e.clientY);
                    let nodeEl = el;
                    while (nodeEl && nodeEl !== document.body && !nodeEl.classList.contains('node')) {
                        nodeEl = nodeEl.parentElement;
                    }
                    if (nodeEl && nodeEl.id && nodeEl.id !== connectingFrom.nodeId) {
                        // Only snap if that node has an input connection point
                        if (nodeEl.querySelector('.connection-point.input')) {
                            chosenNodeId = nodeEl.id;
                            minDist = threshold; // treat as acceptable
                        }
                    }
                }

                if (chosenNodeId && minDist <= threshold) {
                    createConnection(connectingFrom.nodeId, 'output', chosenNodeId, 'input');
                } else {
                    // Dropped on canvas: open quick-add at drop location
                    const pos = { x: mouseX + 10, y: mouseY + 10 };
                    const sourceNodeId = connectingFrom.nodeId;
                    openQuickAddMenu(sourceNodeId, null, pos);
                    // Keep the temp line visible until menu closes
                    keepTemp = true;
                }
            }
            
            connectingFrom = null;
            document.removeEventListener('mousemove', updateTempLine);
            document.removeEventListener('mouseup', endConnection);
            if (wasDragging) {
                suppressQuickAddUntil = Date.now() + 250;
            }
            // Remove temp line if we are not keeping it for the menu
            if (!keepTemp && tempLine) {
                tempLine.remove();
                tempLine = null;
            }
        }

        // Open a minimal quick-add popover to the right of the node's output circle
        function openQuickAddMenu(nodeId, anchorEl, pos /* optional: {x,y} in canvas coords */) {
            // Remove any existing popover DOM without touching temp line
            if (quickAddPopover && quickAddPopover.parentNode) {
                quickAddPopover.parentNode.removeChild(quickAddPopover);
                quickAddPopover = null;
            }
            const nodeEl = document.getElementById(nodeId);
            if (!nodeEl) return;

            // Build popover container (styled via CSS)
            quickAddPopover = document.createElement('div');
            quickAddPopover.className = 'quick-add-popover';

            // Position: if pos given use it; else 50px to the right of the anchor/node
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            const nodeRect = nodeEl.getBoundingClientRect();
            const anchorRect = anchorEl ? anchorEl.getBoundingClientRect() : nodeRect;
            const left = (pos && typeof pos.x === 'number') ? pos.x : (anchorRect.right - canvasRect.left) + 50;
            // Align Y with the source node's top for a straight left->right flow when opened from an output click
            const sourceTop = parseInt(nodeEl.style.top || '0', 10) || (nodeRect.top - canvasRect.top);
            const top = (pos && typeof pos.y === 'number') ? pos.y : sourceTop;
            quickAddPopover.style.left = left + 'px';
            quickAddPopover.style.top = top + 'px';
            // Persist the alignment Y so created nodes use the exact same baseline
            quickAddPopover.dataset.alignY = String(top);

            // Favorites (top 6) just above search
            const favWrap = document.createElement('div');
            favWrap.className = 'quick-add-favs';

            function getFavs() {
                try { return JSON.parse(localStorage.getItem('etlQuickAddFavs')||'[]'); } catch(_) { return []; }
            }
            function setFavs(arr) {
                localStorage.setItem('etlQuickAddFavs', JSON.stringify(arr.slice(0,6)));
            }

            const favSlots = [];
            for (let i=0;i<6;i++) {
                const slot = document.createElement('div');
                slot.className = 'quick-add-fav-slot';
                slot.dataset.index = String(i);
                // Accept drops
                slot.ondragover = (ev)=>{ ev.preventDefault(); };
                slot.ondrop = (ev)=>{
                    ev.preventDefault();
                    const data = ev.dataTransfer.getData('application/json');
                    if (!data) return;
                    const t = JSON.parse(data);
                    const favs = getFavs();
                    favs[i] = { qa: t.qa, label: t.label, emoji: t.emoji };
                    setFavs(favs);
                    renderFavs();
                };
                // Click to create node if filled
                slot.onclick = ()=>{
                    const favs = getFavs();
                    const f = favs[i];
                    if (!f) return;
                    const tool = tools.find(x => x.qa === f.qa) || tools.find(x=>x.label===f.label);
                    if (!tool) return;
                    // Trigger creation same as clicking list item
                    const beforeLen = nodes.length;
                    tool.fn();
                    const newNode = nodes[nodes.length - 1];
                    if (newNode && nodes.length > beforeLen) {
                        // Place exactly where the popover is drawn (keeps UI in sync)
                        if (quickAddPopover) {
                            const px = parseInt(quickAddPopover.style.left||'0',10);
                            const py = quickAddPopover.dataset && quickAddPopover.dataset.alignY ? parseInt(quickAddPopover.dataset.alignY,10) : parseInt(quickAddPopover.style.top||'0',10);
                            newNode.x = Math.max(0, px);
                            newNode.y = Math.max(0, py);
                        } else {
                            const nWidth = nodeEl.offsetWidth || 200;
                            newNode.x = (parseInt(nodeEl.style.left)||0) + nWidth + 120;
                            newNode.y = (parseInt(nodeEl.style.top)||0);
                        }
                        const newEl = document.getElementById(newNode.id);
                        if (newEl) {
                            const prev = newEl.style.transition; newEl.style.transition='none';
                            newEl.style.left = newNode.x + 'px';
                            newEl.style.top = newNode.y + 'px';
                            void newEl.offsetWidth; newEl.style.transition = prev || '';
                        }
                        createConnection(nodeId, 'output', newNode.id, 'input');
                    }
                    closeQuickAddMenu();
                };
                favWrap.appendChild(slot);
                favSlots.push(slot);
            }

            function renderFavs() {
                const favs = getFavs();
                favSlots.forEach((slot, idx)=>{
                    const f = favs[idx];
                    slot.textContent = '';
                    slot.className = 'quick-add-fav-slot';
                    if (f && f.emoji) {
                        slot.textContent = f.emoji;
                        slot.classList.add('filled');
                        if (f.qa) slot.classList.add(f.qa); // apply gradient theme
                    }
                });
            }

            // Search input (CSS styled)
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Search tools…';
            input.className = 'quick-add-search';

            // List container (CSS styled)
            const list = document.createElement('div');
            list.className = 'quick-add-list';
            // Wrapper that hosts fade + arrow indicators
            const wrap = document.createElement('div');
            wrap.className = 'quick-add-list-wrap';
            const fade = document.createElement('div');
            fade.className = 'quick-add-bottom-fade';
            const arrow = document.createElement('div');
            arrow.className = 'quick-add-bottom-arrow';
            arrow.textContent = '▾';
            // Build DOM
            quickAddPopover.appendChild(favWrap);
            wrap.appendChild(list);
            wrap.appendChild(fade);
            wrap.appendChild(arrow);

            // Tool registry (exclude inputs/outputs)
            const tools = [
                { label: 'Any Column Filter', emoji: '🔍', qa: 'qa-anyfilter', group: 'Transforms', fn: createAnyColumnFilterNode },
                { label: 'Column Filter', emoji: '📋', qa: 'qa-columnfilter', group: 'Transforms', fn: createColumnFilterNode },
                { label: 'Aggregation', emoji: '📈', qa: 'qa-aggregate', group: 'Transforms', fn: createAggregationNode },
                { label: 'Measure Filter', emoji: '🧮', qa: 'qa-measurefilter', group: 'Transforms', fn: createMeasureFilterNode },
                { label: 'Joiner', emoji: '🧷', qa: 'qa-joiner', group: 'Transforms', fn: createJoinerNode },
                { label: 'Union', emoji: '🔗', qa: 'qa-union', group: 'Transforms', fn: createUnionNode },
                { label: 'Column Renamer', emoji: '✏️', qa: 'qa-columnrenamer', group: 'Transforms', fn: createColumnRenamerNode },
                { label: 'Wild Headers', emoji: '🌀', qa: 'qa-wildheaders', group: 'Transforms', fn: createWildHeadersNode },
                { label: 'Constant', emoji: '🔧', qa: 'qa-constant', group: 'Transforms', fn: createConstantNode },
                { label: 'Rank', emoji: '🏁', qa: 'qa-rank', group: 'Transforms', fn: createRankNode },
                { label: 'Find/Replace', emoji: '🔎', qa: 'qa-findreplace', group: 'Transforms', fn: createFindReplaceNode },
                { label: 'Sort', emoji: '↕️', qa: 'qa-sort', group: 'Transforms', fn: createSortNode },
                { label: 'Concat', emoji: '🔗', qa: 'qa-stringconcat', group: 'Transforms', fn: createStringConcatNode },
                { label: 'Split', emoji: '✂️', qa: 'qa-stringsplit', group: 'Transforms', fn: createStringSplitNode },
                { label: 'Pivot', emoji: '📊', qa: 'qa-pivot', group: 'Transforms', fn: createPivotNode },
                { label: 'Trim/Normalize', emoji: '🔤', qa: 'qa-normalize', group: 'Transforms', fn: createNormalizeNode },
                { label: 'Null Handler', emoji: '🚫', qa: 'qa-nullvalue', group: 'Transforms', fn: createNullValueNode },
                { label: 'CSV Output', emoji: '💾', qa: 'qa-csvoutput', group: 'Outputs', fn: createCSVOutputNode },
                { label: 'JSON Output', emoji: '🧾', qa: 'qa-jsonoutput', group: 'Outputs', fn: createJSONOutputNode },
                { label: 'Excel Output', emoji: '📄', qa: 'qa-exceloutput', group: 'Outputs', fn: createExcelOutputNode },
            ];

            function renderList(filterText) {
                list.innerHTML = '';
                const f = (filterText || '').toLowerCase();
                const filtered = tools.filter(t => t.label.toLowerCase().includes(f));
                if (!filtered.length) {
                    const empty = document.createElement('div');
                    empty.className = 'quick-add-section';
                    empty.textContent = 'No results';
                    list.appendChild(empty);
                    updateScrollHints();
                    return;
                }
                let lastGroup = '';
                filtered.forEach(t => {
                    if (t.group !== lastGroup) {
                        const header = document.createElement('div');
                        header.className = 'quick-add-section';
                        header.textContent = t.group;
                        list.appendChild(header);
                        lastGroup = t.group;
                    }
                    const btn = document.createElement('button');
                    btn.className = `quick-add-item ${t.qa}`;
                    btn.innerHTML = `<span class="quick-add-emoji">${t.emoji}</span><span class="quick-add-label">${t.label}</span>`;
                    // Drag to favorite slot
                    btn.draggable = true;
                    btn.ondragstart = (ev)=>{
                        ev.dataTransfer.setData('application/json', JSON.stringify({ qa: t.qa, label: t.label, emoji: t.emoji }));
                    };
                    btn.onclick = () => {
                        // Create the node via existing factory
                        const beforeLen = nodes.length;
                        t.fn();
                        const newNode = nodes[nodes.length - 1];
                        if (newNode && nodes.length > beforeLen) {
                            // Place exactly where the popover is drawn (keeps UI in sync)
                            if (quickAddPopover) {
                                const px = parseInt(quickAddPopover.style.left||'0',10);
                                const py = parseInt(quickAddPopover.style.top||'0',10);
                                newNode.x = Math.max(0, px);
                                newNode.y = Math.max(0, py);
                            } else {
                                const nWidth = nodeEl.offsetWidth || 200;
                                newNode.x = (parseInt(nodeEl.style.left)||0) + nWidth + 120;
                                newNode.y = (parseInt(nodeEl.style.top)||0);
                            }
                            const newEl = document.getElementById(newNode.id);
                            if (newEl) {
                                // Suppress transition so it appears at location without flying
                                const prev = newEl.style.transition;
                                newEl.style.transition = 'none';
                                newEl.style.left = newNode.x + 'px';
                                newEl.style.top = newNode.y + 'px';
                                // Force reflow to apply immediately
                                void newEl.offsetWidth;
                                // Restore inline transition (empty lets CSS class rule take over)
                                newEl.style.transition = prev || '';
                            }
                            // Auto-connect current node -> new node
                            createConnection(nodeId, 'output', newNode.id, 'input');
                        }
                        closeQuickAddMenu();
                    };
                    list.appendChild(btn);
                });
                updateScrollHints();
            }

            // Initial favorites render and append the rest of popover structure
            renderFavs();
            quickAddPopover.appendChild(input);
            quickAddPopover.appendChild(wrap);

            function updateScrollHints() {
                // Show fade/arrow when there is more content below
                const hasMore = Math.ceil(list.scrollTop + list.clientHeight) < list.scrollHeight;
                if (hasMore) wrap.classList.add('quick-add-has-more');
                else wrap.classList.remove('quick-add-has-more');
            }
            list.addEventListener('scroll', updateScrollHints);

            input.addEventListener('input', () => renderList(input.value));
            input.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') {
                    const first = list.querySelector('button.quick-add-item');
                    if (first) first.click();
                } else if (ev.key === 'Escape') {
                    closeQuickAddMenu();
                }
            });

            quickAddPopover.appendChild(input);
            quickAddPopover.appendChild(wrap);
            document.getElementById('canvas').appendChild(quickAddPopover);
            renderList('');
            input.focus();

            // Close on outside click
            setTimeout(() => {
                function outside(e) {
                    if (!quickAddPopover) return;
                    if (!quickAddPopover.contains(e.target)) {
                        closeQuickAddMenu();
                        document.removeEventListener('mousedown', outside, true);
                    }
                }
                document.addEventListener('mousedown', outside, true);
            }, 0);
        }

        function closeQuickAddMenu() {
            if (quickAddPopover && quickAddPopover.parentNode) {
                quickAddPopover.parentNode.removeChild(quickAddPopover);
            }
            // When menu closes, remove any lingering temp connection line
            if (tempLine) {
                tempLine.remove();
                tempLine = null;
            }
            quickAddPopover = null;
        }

        // Draw a dotted temp line from an output connection point to the quick-add popover
        function drawTempLineToPopover(nodeId, anchorEl) {
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            const nodeEl = document.getElementById(nodeId);
            if (!nodeEl || !quickAddPopover) return;
            const aRect = (anchorEl || nodeEl).getBoundingClientRect();
            const startX = aRect.right - canvasRect.left; // output is on the right edge
            const startY = aRect.top - canvasRect.top + aRect.height / 2;
            const endX = parseInt(quickAddPopover.style.left || '0', 10) + 12;
            const endY = parseInt(quickAddPopover.style.top || '0', 10) + 24;
            const midX = (startX + endX) / 2;

            const svg = document.getElementById('connectionCanvas');
            if (!svg) return;
            if (tempLine) tempLine.remove();
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempLine.classList.add('temp-line');
            const pathData = `M ${startX} ${startY} Q ${midX} ${startY} ${endX} ${endY}`;
            tempLine.setAttribute('d', pathData);
            svg.appendChild(tempLine);
        }

        function createConnection(fromNodeId, fromType, toNodeId, toType) {
            // Only meaningful if output -> input
            if (!(fromType === 'output' && toType === 'input')) return;
            // Prevent duplicate edges
            const exists = connections.some(c => c.from === fromNodeId && c.to === toNodeId && c.fromType === fromType && c.toType === toType);
            if (exists) return;
            // Ensure adjacency entries exist
            if (!outNeighbors.has(fromNodeId)) outNeighbors.set(fromNodeId, new Set());
            if (!inNeighbors.has(toNodeId)) inNeighbors.set(toNodeId, new Set());
            // Provisional add to adjacency and check for cycle (would create path to itself)
            outNeighbors.get(fromNodeId).add(toNodeId);
            inNeighbors.get(toNodeId).add(fromNodeId);
            const wouldCycle = hasPath(toNodeId, fromNodeId);
            if (wouldCycle) {
                // Revert provisional add
                outNeighbors.get(fromNodeId).delete(toNodeId);
                inNeighbors.get(toNodeId).delete(fromNodeId);
                return; // reject cycle silently for now
            }
            const connection = {
                id: `conn_${connections.length}`,
                from: fromNodeId,
                fromType: fromType,
                to: toNodeId,
                toType: toType
            };
            connections.push(connection);
            updateConnections();
            // compute target immediately if inputs are ready to show preview instantly
            if (inputsReady(toNodeId)) {
                computeNodeIfReady(toNodeId);
            } else {
                // Special-case: Joiner/Find-Replace and sink outputs should show passthrough from first input even before fully ready
                const toNode = nodes.find(n => n.id === toNodeId);
                if (toNode) {
                    const ins = connections.filter(c => c.to === toNodeId && c.toType === 'input');
                    if (ins.length >= 1) {
                        const src = nodes.find(n => n.id === ins[0].from);
                        if (src && (toNode.type === 'joiner' || toNode.type === 'findreplace' || toNode.type === 'csvoutput' || toNode.type === 'jsonoutput' || toNode.type === 'exceloutput')) {
                            processNodeData(toNode, Array.isArray(src.data) ? src.data : [], Array.isArray(src.headers) ? src.headers : (src.data && src.data[0] ? Object.keys(src.data[0]) : []));
                        }
                    }
                }
            }
            // then mark downstream from the target as dirty and schedule recompute
            markDirty(toNodeId);
            scheduleRecompute();
        }

        function updateConnections() {
            const svg = document.getElementById('connectionCanvas');
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Ensure arrow marker exists
            if (!svg.querySelector('#arrowhead')) {
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'arrowhead');
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                marker.setAttribute('markerUnits', 'strokeWidth');
                
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                polygon.setAttribute('fill', '#4f46e5');
                
                marker.appendChild(polygon);
                defs.appendChild(marker);
                svg.appendChild(defs);
            }
            
            // Clear existing connections
            svg.querySelectorAll('.connection-line-svg').forEach(line => line.remove());
            // Clear existing twin links
            svg.querySelectorAll('.twin-line').forEach(line => line.remove());
            
            connections.forEach(conn => {
                const fromNode = document.getElementById(conn.from);
                const toNode = document.getElementById(conn.to);
                
                if (!fromNode || !toNode) return;
                
                // Get node positions relative to canvas
                const fromX = parseInt(fromNode.style.left) || 0;
                const fromY = parseInt(fromNode.style.top) || 0;
                const toX = parseInt(toNode.style.left) || 0;
                const toY = parseInt(toNode.style.top) || 0;
                
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                
                let startX, startY, endX, endY;
                
                if (conn.fromType === 'output') {
                    startX = fromX + fromRect.width;
                    startY = fromY + fromRect.height / 2;
                } else {
                    startX = fromX;
                    startY = fromY + fromRect.height / 2;
                }
                
                if (conn.toType === 'input') {
                    endX = toX;
                    endY = toY + toRect.height / 2;
                } else {
                    endX = toX + toRect.width;
                    endY = toY + toRect.height / 2;
                }
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.classList.add('connection-line-svg');
                
                const midX = (startX + endX) / 2;
                const pathData = `M ${startX} ${startY} Q ${midX} ${startY} ${endX} ${endY}`;
                path.setAttribute('d', pathData);
                
                svg.appendChild(path);
            });

            // Draw gray dotted counterpart twin links (orig bottom center -> clone top center)
            counterpartOf.forEach((cloneId, origId) => {
                const origEl = document.getElementById(origId);
                const cloneEl = document.getElementById(cloneId);
                if (!origEl || !cloneEl) return;

                const oX = parseInt(origEl.style.left) || 0;
                const oY = parseInt(origEl.style.top) || 0;
                const cX = parseInt(cloneEl.style.left) || 0;
                const cY = parseInt(cloneEl.style.top) || 0;
                const oRect = origEl.getBoundingClientRect();
                const cRect = cloneEl.getBoundingClientRect();

                const startX = oX + oRect.width / 2;
                const startY = oY + oRect.height; // bottom center of original
                const endX = cX + cRect.width / 2;
                const endY = cY; // top center of clone

                const twin = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                twin.classList.add('twin-line');
                // Gentle vertical curve
                const midY = (startY + endY) / 2;
                const pathData = `M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`;
                twin.setAttribute('d', pathData);
                svg.appendChild(twin);
            });
        }

        // Handle click on output circle to open quick-add (only if not dragging)
        document.addEventListener('click', (e) => {
            const el = e.target;
            if (el.classList && el.classList.contains('connection-point') && el.classList.contains('output')) {
                // If we are in the middle of a drag, ignore click
                if (isDraggingConnection || tempLine) return;
                if (Date.now() < suppressQuickAddUntil) return;
                const nodeId = el.parentElement && el.parentElement.id;
                if (nodeId) {
                    // Compute position with strict left->right alignment (Y = source node top)
                    const canvas = document.getElementById('canvas');
                    const canvasRect = canvas.getBoundingClientRect();
                    const aRect = el.getBoundingClientRect();
                    const parentRect = el.parentElement.getBoundingClientRect();
                    const nodeTop = parentRect.top - canvasRect.top;
                    const pos = {
                        x: (aRect.right - canvasRect.left) + 50,
                        y: nodeTop
                    };
                    openQuickAddMenu(nodeId, el, pos);
                    // After opening, draw a dotted line from output to the popover
                    drawTempLineToPopover(nodeId, el);
                }
            }
        });

        // ===== 
        // ===== 
        // ===== 
        // ===== node brain =====
        // ===== ' awe so special, "I do the thinking" '
        // ===== 
        // ===== 

        function propagateData(fromNodeId) {
            // Legacy path retained but routed to dirty-queue for minimal change
            markDirty(fromNodeId);
            scheduleRecompute();
        }

        function processNodeData(node, inputData, inputHeaders) {
            let processedData = [...inputData];
            let outputHeaders = [...inputHeaders];
            // Minimal impact metadata reset each run
            node.impact = { columns: [] };
            
            if (node.type === 'csvoutput' || node.type === 'jsonoutput' || node.type === 'exceloutput') {
                // Passthrough: do not alter data, only used for exporting
                processedData = inputData;
                outputHeaders = inputHeaders;
            }
            
            if (node.type === 'filter') {
                const pattern = (node.pattern || '').toString();
                if (!pattern) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                    node.impact = { columns: [] };
                } else {
                    let re;
                    try {
                        if (node.useRegex) {
                            // True regex path
                            re = new RegExp(pattern, node.caseSensitive ? '' : 'i');
                        } else {
                            const hasWild = /[\*\?]/.test(pattern);
                            if (hasWild) {
                                // Wildcard -> regex, anchored to full cell
                                const escWild = pattern
                                    .replace(/[-\/\\^$+?.()|[\]{}]/g, '\\$&')
                                    .replace(/\*/g, '.*')
                                    .replace(/\?/g, '.');
                                re = new RegExp('^' + escWild + '$', node.caseSensitive ? '' : 'i');
                            } else {
                                // Pure literal entire-cell match
                                const escLit = pattern.replace(/[-\/\\^$+?.()|[\]{}]/g, '\\$&');
                                re = new RegExp('^' + escLit + '$', node.caseSensitive ? '' : 'i');
                            }
                        }
                    } catch (e) {
                        re = null;
                    }
                    const keepMode = (node.mode === 'keep');
                    const matches = (val) => {
                        const str = val == null ? '' : String(val);
                        return re ? re.test(str) : true;
                    };
                    processedData = (inputData || []).filter(record => {
                        const anyMatch = Object.values(record).some(v => matches(v));
                        return keepMode ? anyMatch : !anyMatch;
                    });
                    // Highlight only columns that actually have any matching cell
                    const impacted = (inputHeaders || []).filter(h =>
                        (inputData || []).some(r => matches(r && r[h]))
                    );
                    node.impact = { columns: impacted };
                }
            } else if (node.type === 'columnfilter') {
                if (node.column && (node.pattern || node.pattern === '')) {
                    const pattern = (node.pattern || '').toString();
                    let re;
                    try {
                        if (node.useRegex) {
                            re = new RegExp(pattern, node.caseSensitive ? '' : 'i');
                        } else {
                            const hasWild = /[\*\?]/.test(pattern);
                            if (hasWild) {
                                const escWild = pattern.replace(/[-\/\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*').replace(/\?/g, '.');
                                re = new RegExp('^' + escWild + '$', node.caseSensitive ? '' : 'i');
                            } else {
                                const escLit = pattern.replace(/[-\/\\^$+?.()|[\]{}]/g, '\\$&');
                                re = new RegExp('^' + escLit + '$', node.caseSensitive ? '' : 'i');
                            }
                        }
                    } catch (e) {
                        re = null;
                    }
                    const keepMode = (node.mode === 'keep');
                    const matches = (val) => {
                        const str = val == null ? '' : String(val);
                        return re ? re.test(str) : true;
                    };
                    processedData = (inputData || []).filter(record => {
                        const ok = matches(record[node.column]);
                        return keepMode ? ok : !ok;
                    });
                    node.impact = { columns: node.column ? [node.column] : [] };
                } else {
                    processedData = inputData;
                    node.impact = { columns: [] };
                }
            } else if (node.type === 'union') {
                // Union processing - collect all input data
                const inputConnections = connections.filter(conn => 
                    conn.to === node.id && conn.toType === 'input'
                );
                
                if (inputConnections.length > 0) {
                    processedData = [];
                    let firstHeaders = null;
                    
                    inputConnections.forEach((conn, idx) => {
                        const inputNode = nodes.find(n => n.id === conn.from);
                        if (inputNode && inputNode.data) {
                            if (!firstHeaders) {
                                firstHeaders = [...inputNode.headers];
                                outputHeaders = firstHeaders;
                            }
                            // Tag rows with the originating input index; used only for preview row highlighting
                            const tagged = (Array.isArray(inputNode.data) ? inputNode.data : []).map(r => {
                                if (r && typeof r === 'object') {
                                    // Avoid mutating upstream objects
                                    const copy = { ...r };
                                    copy.__unionFromIdx = idx;
                                    return copy;
                                }
                                return { value: r, __unionFromIdx: idx };
                            });
                            processedData = processedData.concat(tagged);
                        }
                    });
                    
                    // Optional deduplication
                    if (node.removeDuplicates && Array.isArray(processedData)) {
                        const seen = new Set();
                        const headers = outputHeaders && outputHeaders.length ? outputHeaders : (inputHeaders || []);
                        processedData = processedData.filter(row => {
                            if (row && typeof row === 'object') {
                                const key = JSON.stringify(headers.map(h => row[h]));
                                if (seen.has(key)) return false;
                                seen.add(key);
                                return true;
                            }
                            const key = String(row);
                            if (seen.has(key)) return false;
                            seen.add(key);
                            return true;
                        });
                    }
                }
                // Union is passthrough; no specific column highlight
                node.impact = { columns: [] };
            } else if (node.type === 'wildheaders') {
                // Pattern-based header filter (keep/remove columns by header match)
                const pattern = (node.pattern || '').toString();
                // Passthrough if no pattern or no headers
                if (!pattern || !inputHeaders || !inputHeaders.length) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                } else {
                    let re;
                    try {
                        if (node.useRegex) {
                            re = new RegExp(pattern, node.caseSensitive ? '' : 'i');
                        } else {
                            // Escape regex special chars except * and ? then convert wildcards
                            const esc = pattern.replace(/[-\/\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*').replace(/\?/g, '.');
                            re = new RegExp('^' + esc + '$', node.caseSensitive ? '' : 'i');
                        }
                    } catch (e) {
                        // Fallback to passthrough on invalid regex
                        re = null;
                    }
                    const keepMode = (node.mode === 'keep');
                    const matches = (h) => re ? re.test(h.toString()) : true;
                    const selected = inputHeaders.filter(h => keepMode ? matches(h) : !matches(h));
                    outputHeaders = selected;
                    processedData = (inputData || []).map(row => {
                        const nr = {};
                        outputHeaders.forEach(h => { nr[h] = row[h]; });
                        return nr;
                    });
                    // Wild Headers filters columns but shouldn't highlight them
                    node.impact = { columns: [] };
                }
            } else if (node.type === 'columnrenamer') {
                // Merge new upstream columns with existing column order
                let orderedHeaders = [...inputHeaders];
                
                // If we have a custom column order, preserve it but add any new columns
                if (node.columnOrder.length > 0) {
                    const existingColumns = node.columnOrder.filter(col => inputHeaders.includes(col));
                    const newColumns = inputHeaders.filter(col => !node.columnOrder.includes(col));
                    orderedHeaders = [...existingColumns, ...newColumns];
                    // Update the node's column order to include new columns
                    node.columnOrder = orderedHeaders;
                }
                
                updateColumnRenamerConfig(node.id, orderedHeaders);
                
                processedData = inputData.map(record => {
                    const newRecord = {};
                    orderedHeaders.forEach(header => {
                        if (!node.removals.includes(header) && record.hasOwnProperty(header)) {
                            const newName = node.renames[header] || header;
                            newRecord[newName] = record[header];
                        }
                    });
                    return newRecord;
                });
                
                outputHeaders = orderedHeaders
                    .filter(h => !node.removals.includes(h) && inputHeaders.includes(h))
                    .map(h => node.renames[h] || h);
                // Highlight renamed columns (new names) and moved columns
                const renamed = Object.entries(node.renames || {})
                    .filter(([oldN, newN]) => newN && newN !== oldN && inputHeaders.includes(oldN))
                    .map(([, newN]) => newN);
                
                // Combine renamed columns with moved columns for highlighting
                const movedColumns = node.movedColumns || [];
                const allHighlightedColumns = [...new Set([...renamed, ...movedColumns])];
                node.impact = { columns: allHighlightedColumns };
            } else if (node.type === 'aggregate') {
                // Aggregation processing
                if (!node.groupBy) {
                    // KPI-style single aggregate over entire dataset
                    const op = (node.measureOp === 'mean') ? 'avg' : (node.measureOp || 'count');
                    const col = node.measureCol;
                    updateColumnOptions(node.id, inputHeaders);
                    if (op === 'count') {
                        const header = `count_${col || 'rows'}`;
                        const val = inputData.length;
                        node.data = [{ [header]: val }];
                        node.headers = [header];
                        updateNodePreview(node.id, node.data, node.headers);
                        propagateData(node.id);
                        return;
                    }
                    if (!col) {
                        // Need a measure column for sum/avg/mean
                        node.data = [];
                        node.headers = [];
                        updateNodePreview(node.id, [], []);
                        return;
                    }
                    let result = null;
                    if (op === 'sum' || op === 'avg') {
                        const nums = inputData
                            .map(r => parseFloat(r[col]))
                            .filter(v => Number.isFinite(v));
                        if (nums.length) {
                            const sum = nums.reduce((s, v) => s + v, 0);
                            result = (op === 'sum') ? sum : (sum / nums.length);
                        } else {
                            result = null; // no numeric values -> null so Null node can handle
                        }
                    }
                    const header = `${op}_${col}`;
                    node.data = [{ [header]: result }];
                    node.headers = [header];
                    node.impact = { columns: [header] };
                    updateNodePreview(node.id, node.data, node.headers);
                    propagateData(node.id);
                    return;
                }
                const groupMap = new Map();
                inputData.forEach(rec => {
                    const key = (rec[node.groupBy] ?? '').toString();
                    if (!groupMap.has(key)) groupMap.set(key, []);
                    groupMap.get(key).push(rec);
                });
                const op = (node.measureOp === 'mean') ? 'avg' : (node.measureOp || 'count');
                const col = node.measureCol;
                if (op !== 'count' && !col) {
                    // Need a measure column for sum/avg/mean when grouping
                    node.data = [];
                    node.headers = [];
                    updateColumnOptions(node.id, inputHeaders);
                    updateNodePreview(node.id, [], []);
                    return;
                }
                const rows = [];
                groupMap.forEach((arr, key) => {
                    let val = null;
                    if (op === 'count') {
                        val = arr.length;
                    } else if (op === 'sum' || op === 'avg') {
                        const nums = arr
                            .map(r => parseFloat(r[col]))
                            .filter(v => Number.isFinite(v));
                        if (nums.length) {
                            const sum = nums.reduce((s, v) => s + v, 0);
                            val = (op === 'sum') ? sum : (sum / nums.length);
                        } else {
                            val = null; // all non-numeric -> null
                        }
                    }
                    rows.push({ [node.groupBy]: key, [`${op}_${col || 'rows'}`]: val });
                });
                processedData = rows;
                outputHeaders = [node.groupBy, `${op}_${col || 'rows'}`];
                // Keep selects updated
                updateColumnOptions(node.id, inputHeaders);
                node.impact = { columns: outputHeaders };
            } else if (node.type === 'measurefilter') {
                if (node.column && node.operator && node.value !== '') {
                    const val = parseFloat(node.value);
                    const rowMatches = (r) => {
                        const v = parseFloat(r[node.column]);
                        if (isNaN(v)) return false;
                        switch (node.operator) {
                            case '>': return v > val;
                            case '>=': return v >= val;
                            case '<': return v < val;
                            case '<=': return v <= val;
                            case '==': return v == val;
                            case '!=': return v != val;
                            default: return true;
                        }
                    };
                    const keepMode = (node.mode === 'keep');
                    processedData = inputData.filter(r => keepMode ? rowMatches(r) : !rowMatches(r));
                }
                // Keep selects updated
                updateColumnOptions(node.id, inputHeaders);
                node.impact = { columns: node.column ? [node.column] : [] };
            } else if (node.type === 'constant') {
                const col = node.column || 'const';
                const val = (typeof node.value === 'undefined') ? '' : node.value;
                if (!outputHeaders.includes(col)) outputHeaders = [...outputHeaders, col];
                processedData = inputData.map(r => ({ ...r, [col]: val }));
                node.impact = { columns: [col] };
            } else if (node.type === 'rank') {
                // rank requires a column
                updateColumnOptions(node.id, inputHeaders);
                const col = node.column;
                const order = node.order === 'asc' ? 'asc' : 'desc';
                const outCol = node.outColumn || 'rank';
                if (!col) {
                    // Passthrough preview until a column is chosen
                    node.data = inputData;
                    node.headers = inputHeaders;
                    updateNodePreview(node.id, inputData.slice(0,5), inputHeaders);
                    markDirty(node.id);
                    scheduleRecompute();
                    return;
                }
                // Copy and sort indices
                const arr = inputData.map((r, i) => ({ i, v: parseFloat(r[col]) }));
                arr.sort((a, b) => {
                    const av = isNaN(a.v) ? -Infinity : a.v;
                    const bv = isNaN(b.v) ? -Infinity : b.v;
                    return order === 'asc' ? av - bv : bv - av;
                });
                const rankByIndex = new Array(inputData.length);
                arr.forEach((e, idx) => { rankByIndex[e.i] = idx + 1; });
                if (!outputHeaders.includes(outCol)) outputHeaders = [...outputHeaders, outCol];
                processedData = inputData.map((r, i) => ({ ...r, [outCol]: rankByIndex[i] }));
                node.impact = { columns: [outCol] };
                // Fallback: if something goes wrong and no rows, still show upstream preview
                if ((!processedData || processedData.length === 0) && inputData && inputData.length) {
                    updateNodePreview(node.id, inputData.slice(0, 5), inputHeaders);
                }
            } else if (node.type === 'findreplace') {
                // Keep column dropdown in sync
                updateColumnOptions(node.id, inputHeaders);
                // Auto-select a default column if none chosen
                if ((!node.column || !inputHeaders.includes(node.column)) && inputHeaders.length) {
                    node.column = inputHeaders[0];
                    const sel = document.getElementById(`frCol_${node.id}`);
                    if (sel) sel.value = node.column;
                }
                const col = node.column;
                // If no pattern, passthrough to show live preview and aid configuration
                if (!col || !node.pattern) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                } else {
                    // Build regex per options
                    const pat = String(node.pattern);
                    let re;
                    try {
                        if (node.useRegex) {
                            const flags = node.caseSensitive ? '' : 'i';
                            const f = node.replaceAll ? flags + 'g' : flags;
                            re = new RegExp(node.wholeCell ? `^${pat}$` : pat, f);
                        } else {
                            const hasWild = /[\*\?]/.test(pat);
                            const esc = pat.replace(/[-\/\\^$+?.()|[\]{}]/g, '\\$&');
                            const base = hasWild ? esc.replace(/\*/g, '.*').replace(/\?/g, '.') : esc;
                            const body = node.wholeCell ? `^${base}$` : base;
                            const flags = node.caseSensitive ? '' : 'i';
                            const f = node.replaceAll ? flags + 'g' : flags;
                            re = new RegExp(body, f);
                        }
                    } catch (e) {
                        re = null;
                    }
                    processedData = inputData.map(r => {
                        const v = (r[col] ?? '').toString();
                        if (!re) return { ...r };
                        const replaced = v.replace(re, node.replacement || '');
                        return { ...r, [col]: replaced };
                    });
                    outputHeaders = inputHeaders;
                }
                node.impact = { columns: col ? [col] : [] };
            } else if (node.type === 'joiner') {
                // Pull two inputs explicitly; ignore inputData
                const ins = connections.filter(c => c.to === node.id && c.toType === 'input');
                if (ins.length < 2) {
                    // Passthrough from first available upstream to aid configuration
                    if (ins.length >= 1) {
                        const first = nodes.find(n => n.id === ins[0].from);
                        processedData = (first && first.data) ? first.data : [];
                        outputHeaders = (first && first.headers) ? first.headers : [];
                    } else {
                        processedData = [];
                        outputHeaders = [];
                    }
                } else {
                    const leftNode = nodes.find(n => n.id === ins[0].from);
                    const rightNode = nodes.find(n => n.id === ins[1].from);
                    const leftData = (leftNode && leftNode.data) ? leftNode.data : [];
                    const rightData = (rightNode && rightNode.data) ? rightNode.data : [];
                    const leftHeaders = (leftNode && leftNode.headers) ? leftNode.headers : [];
                    const rightHeaders = (rightNode && rightNode.headers) ? rightNode.headers : [];

                    // Auto-infer keys if not set: choose first common header
                    let lk = node.leftKey;
                    let rk = node.rightKey;
                    if (!lk || !rk) {
                        const common = leftHeaders.filter(h => rightHeaders.includes(h));
                        if (common.length) {
                            // Heuristic: prefer id-like names
                            const pref = ['id','ID','Id','key','Key','name','Name','rank'];
                            const pick = pref.find(p => common.includes(p)) || common[0];
                            lk = rk = pick;
                            node.leftKey = lk;
                            node.rightKey = rk;
                            // Update UI fields if present
                            const lEl = document.getElementById(`leftKey_${node.id}`);
                            const rEl = document.getElementById(`rightKey_${node.id}`);
                            if (lEl) lEl.value = lk;
                            if (rEl) rEl.value = rk;
                        }
                    }

                    if (!lk || !rk) {
                        // Still no keys: fallback to passthrough of left
                        processedData = leftData;
                        outputHeaders = leftHeaders;
                    } else {
                        // Perform join using inferred/provided keys
                        const map = new Map();
                        rightData.forEach(r => {
                            const key = (r[rk] ?? '').toString();
                            if (!map.has(key)) map.set(key, []);
                            map.get(key).push(r);
                        });
                        const mergedHeaders = [...leftHeaders];
                        rightHeaders.forEach(h => {
                            if (!mergedHeaders.includes(h)) mergedHeaders.push(h);
                        });
                        outputHeaders = mergedHeaders;
                        processedData = [];
                        leftData.forEach(lr => {
                            const k = (lr[lk] ?? '').toString();
                            const matches = map.get(k) || [];
                            if (matches.length) {
                                matches.forEach(rr => {
                                    processedData.push({ ...rr, ...lr });
                                });
                            } else if (node.joinType === 'left') {
                                // left join: keep left row with right fields undefined
                                processedData.push({ ...lr });
                            }
                        });
                    }
                    // Highlight join keys and any extra columns introduced from the right side
                    const extraCols = rightHeaders.filter(h => !leftHeaders.includes(h));
                    const cols = [];
                    if (lk) cols.push(lk);
                    if (rk && rk !== lk) cols.push(rk);
                    node.impact = { columns: Array.from(new Set([...cols, ...extraCols])) };
                }
            }
            else if (node.type === 'sort') {
                // Ensure sorts config exists
                if (!Array.isArray(node.sorts) || node.sorts.length === 0) {
                    node.sorts = [{ column: '', type: 'alpha', order: 'asc' }];
                }
                // Keep UI criteria synced with latest headers
                renderSortCriteria(node.id, inputHeaders);
                // Active criteria only where a column is selected
                const active = node.sorts.filter(s => s && s.column);
                if (!active.length) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                } else {
                    // Stable multi-criteria sort using decorate-sort-undecorate
                    const decorated = (inputData || []).map((row, idx) => ({ idx, row }));
                    const cmp = (a, b) => {
                        for (const crit of active) {
                            const col = crit.column;
                            const type = crit.type || 'alpha';
                            const dir = (crit.order === 'desc') ? -1 : 1;
                            const av = a.row[col];
                            const bv = b.row[col];
                            let c = 0;
                            if (type === 'numeric') {
                                const na = parseFloat(av);
                                const nb = parseFloat(bv);
                                const aa = isNaN(na) ? -Infinity : na;
                                const bb = isNaN(nb) ? -Infinity : nb;
                                c = aa === bb ? 0 : (aa < bb ? -1 : 1);
                            } else if (type === 'date') {
                                const da = new Date(av);
                                const db = new Date(bv);
                                const ta = isNaN(da.getTime()) ? -Infinity : da.getTime();
                                const tb = isNaN(db.getTime()) ? -Infinity : db.getTime();
                                c = ta === tb ? 0 : (ta < tb ? -1 : 1);
                            } else { // alpha
                                const sa = (av ?? '').toString();
                                const sb = (bv ?? '').toString();
                                c = sa.localeCompare(sb, undefined, { sensitivity: 'base' });
                            }
                            if (c !== 0) return c * dir;
                        }
                        return a.idx - b.idx; // stable tie-breaker
                    };
                    decorated.sort(cmp);
                    processedData = decorated.map(d => d.row);
                    outputHeaders = inputHeaders;
                }
                node.impact = { columns: active.map(s => s.column) };
            } else if (node.type === 'stringconcat') {
                // Update column selection UI
                updateStringConcatColumnOptions(node.id, inputHeaders);
                
                // If no columns selected, passthrough
                if (!node.columns || node.columns.length === 0) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                } else {
                    const separator = node.separator === undefined ? '' : node.separator;
                    const outputCol = node.outputColumn || 'concatenated';
                    
                    // Create new data with concatenated column
                    processedData = inputData.map(record => {
                        const values = node.columns
                            .filter(col => inputHeaders.includes(col))
                            .map(col => (record[col] ?? '').toString());
                        const concatenated = values.join(separator);
                        
                        if (node.keepOriginal) {
                            // Keep all original columns plus new one
                            return { ...record, [outputCol]: concatenated };
                        } else {
                            // Remove original columns, keep only non-concatenated ones plus new one
                            const newRecord = { [outputCol]: concatenated };
                            inputHeaders.forEach(header => {
                                if (!node.columns.includes(header)) {
                                    newRecord[header] = record[header];
                                }
                            });
                            return newRecord;
                        }
                    });
                    
                    // Update output headers
                    if (node.keepOriginal) {
                        outputHeaders = [...inputHeaders];
                        if (!outputHeaders.includes(outputCol)) {
                            outputHeaders.push(outputCol);
                        }
                    } else {
                        outputHeaders = inputHeaders.filter(h => !node.columns.includes(h));
                        if (!outputHeaders.includes(outputCol)) {
                            outputHeaders.push(outputCol);
                        }
                    }
                    node.impact = { columns: [outputCol] };
                }
            } else if (node.type === 'stringsplit') {
                // Update column selection UI
                updateStringSplitColumnOptions(node.id, inputHeaders);
                
                // If no columns selected, passthrough
                if (!node.columns || node.columns.length === 0) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                } else {
                    const delimiter = node.delimiter || ',';
                    const maxSplits = Math.max(1, Math.min(10, node.maxSplits || 2));
                    
                    // Create new data with split columns
                    processedData = inputData.map(record => {
                        let newRecord = node.keepOriginal ? { ...record } : {};
                        
                        // Copy non-split columns if not keeping original
                        if (!node.keepOriginal) {
                            inputHeaders.forEach(header => {
                                if (!node.columns.includes(header)) {
                                    newRecord[header] = record[header];
                                }
                            });
                        }
                        
                        // Process each selected column
                        node.columns.forEach(col => {
                            if (inputHeaders.includes(col)) {
                                const value = (record[col] ?? '').toString();
                                const parts = value.split(delimiter, maxSplits);
                                
                                // Create split columns
                                for (let i = 0; i < maxSplits; i++) {
                                    const splitColName = `${col}_${i + 1}`;
                                    newRecord[splitColName] = parts[i] || '';
                                }
                                
                                // Remove original column if not keeping
                                if (!node.keepOriginal) {
                                    delete newRecord[col];
                                }
                            }
                        });
                        
                        return newRecord;
                    });
                    
                    // Update output headers
                    const newSplitHeaders = [];
                    node.columns.forEach(col => {
                        if (inputHeaders.includes(col)) {
                            for (let i = 0; i < maxSplits; i++) {
                                newSplitHeaders.push(`${col}_${i + 1}`);
                            }
                        }
                    });
                    
                    if (node.keepOriginal) {
                        outputHeaders = [...inputHeaders, ...newSplitHeaders];
                    } else {
                        outputHeaders = inputHeaders.filter(h => !node.columns.includes(h)).concat(newSplitHeaders);
                    }
                    
                    node.impact = { columns: newSplitHeaders };
                }
            } else if (node.type === 'normalize') {
                // Update column options for normalize node
                updateNormalizeColumnOptions(node.id, inputHeaders);
                const cols = Array.isArray(node.columns) ? node.columns.filter(c => inputHeaders.includes(c)) : [];
                if (!cols.length) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                } else {
                    const trimEnds = !!node.trimEnds;
                    const collapse = !!node.collapseSpaces;
                    const removeSpecial = !!node.removeSpecial;
                    const mode = node.caseMode || 'none';
                    const toTitle = (s) => s.replace(/\S+/g, w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase());
                    // Unicode whitespace sets
                    const unicodeSpaces = /[\u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]/g; // NBSP and others
                    const zeroWidth = /[\u200B-\u200D\uFEFF]/g; // remove
                    processedData = (inputData || []).map(row => {
                        const r = { ...row };
                        cols.forEach(col => {
                            let v = (r[col] ?? '').toString();
                            if (trimEnds) v = v.trim();
                            if (collapse) {
                                // Remove all whitespace (including Unicode) entirely
                                v = v.replace(zeroWidth, '');
                                v = v.replace(unicodeSpaces, '');
                                v = v.replace(/\s+/g, '');
                            }
                            if (removeSpecial) {
                                // Remove non-alphanumeric characters
                                v = v.replace(/[^A-Za-z0-9]/g, '');
                            }
                            if (mode === 'lower') v = v.toLowerCase();
                            else if (mode === 'upper') v = v.toUpperCase();
                            else if (mode === 'title') v = toTitle(v);
                            r[col] = v;
                        });
                        return r;
                    });
                    outputHeaders = inputHeaders;
                    node.impact = { columns: [...cols] };
                }
            } else if (node.type === 'pivot') {
                // Update column options for pivot selects
                updatePivotColumnOptions(node.id, inputHeaders);
                
                // If required fields not set, passthrough
                if (!node.rowFields || node.rowFields.length === 0 || !node.columnField) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                } else {
                    // Create pivot table with multiple row fields (grouping)
                    const rowFields = node.rowFields;
                    const columnField = node.columnField;
                    const valueField = node.valueField;
                    const aggregation = node.aggregation || 'count';
                    
                    // Get unique column values
                    const columnValues = [...new Set(inputData.map(r => r[columnField] || ''))].sort();
                    
                    // Group data by row field combinations
                    const groupedData = {};
                    inputData.forEach(record => {
                        // Create composite key from all row fields
                        const rowKey = rowFields.map(field => record[field] || '').join('|');
                        const colVal = record[columnField] || '';
                        
                        if (!groupedData[rowKey]) {
                            groupedData[rowKey] = {
                                rowData: {},
                                columns: {}
                            };
                            // Store individual row field values
                            rowFields.forEach(field => {
                                groupedData[rowKey].rowData[field] = record[field] || '';
                            });
                        }
                        
                        if (!groupedData[rowKey].columns[colVal]) {
                            groupedData[rowKey].columns[colVal] = [];
                        }
                        groupedData[rowKey].columns[colVal].push(record);
                    });
                    
                    // Calculate aggregated values
                    processedData = Object.keys(groupedData).map(rowKey => {
                        const group = groupedData[rowKey];
                        const row = { ...group.rowData };
                        
                        columnValues.forEach(colVal => {
                            const records = group.columns[colVal] || [];
                            let value = 0;
                            
                            if (aggregation === 'count') {
                                value = records.length;
                            } else if (valueField && records.length > 0) {
                                const values = records.map(r => parseFloat(r[valueField]) || 0);
                                switch (aggregation) {
                                    case 'sum':
                                        value = values.reduce((a, b) => a + b, 0);
                                        break;
                                    case 'avg':
                                        value = values.reduce((a, b) => a + b, 0) / values.length;
                                        break;
                                    case 'min':
                                        value = Math.min(...values);
                                        break;
                                    case 'max':
                                        value = Math.max(...values);
                                        break;
                                    default:
                                        value = values.length;
                                }
                            }
                            
                            row[colVal] = value;
                        });
                        return row;
                    });
                    
                    // Set output headers (all row fields + column values)
                    outputHeaders = [...rowFields, ...columnValues];
                    node.impact = { columns: outputHeaders };
                }
            } else if (node.type === 'nullvalue') {
                // Update column options for null value node
                updateNullValueColumnOptions(node.id, inputHeaders);
                
                // If no columns selected, passthrough
                if (!node.columns || node.columns.length === 0) {
                    processedData = inputData;
                    outputHeaders = inputHeaders;
                } else {
                    const action = node.action || 'remove';
                    const replaceValue = node.replaceValue || '';
                    const columnsToProcess = node.columns;
                    
                    if (action === 'remove') {
                        // Remove rows that have null/empty values in selected columns
                        processedData = inputData.filter(row => {
                            return columnsToProcess.every(col => {
                                const value = row[col];
                                return value !== null && value !== undefined && value !== '';
                            });
                        });
                    } else if (action === 'replace') {
                        // Replace null/empty values with specified value
                        processedData = inputData.map(row => {
                            const newRow = { ...row };
                            columnsToProcess.forEach(col => {
                                const value = newRow[col];
                                if (value === null || value === undefined || value === '') {
                                    newRow[col] = replaceValue;
                                }
                            });
                            return newRow;
                        });
                    } else {
                        // Keep as-is (passthrough)
                        processedData = inputData;
                    }
                    
                    outputHeaders = inputHeaders;
                    node.impact = { columns: [...columnsToProcess] };
                }
            } else if (node.type === 'csvoutput' || node.type === 'jsonoutput' || node.type === 'exceloutput') {
                // Passthrough logic for sink outputs
                processedData = inputData;
                outputHeaders = inputHeaders;
            }
            
            // Update node data and preview
            // For Union, strip preview-only markers before propagation
            if (node.type === 'union' && Array.isArray(processedData)) {
                node.data = processedData.map(r => {
                    if (r && typeof r === 'object') {
                        const { __unionFromIdx, ...rest } = r;
                        return rest;
                    }
                    return r;
                });
            } else {
                node.data = processedData;
            }
            node.headers = outputHeaders;
            updateNodePreview(node.id, processedData.slice(0, 5), outputHeaders);
            
            // Update column options for nodes with column selects
            if (node.type === 'columnfilter') {
                updateColumnOptions(node.id, inputHeaders);
            }
            // Wild headers has no column dropdowns, nothing to sync
            // Update options for aggregate / measure filter / rank / findreplace / pivot as well
            if (node.type === 'aggregate' || node.type === 'measurefilter' || node.type === 'rank' || node.type === 'findreplace' || node.type === 'pivot') {
                updateColumnOptions(node.id, inputHeaders);
            }
            // Ensure sort node settings show latest headers
            if (node.type === 'sort') {
                renderSortCriteria(node.id, inputHeaders);
            }
            
            // Propagate to next nodes via dirty queue
            markDirty(node.id);
            scheduleRecompute();
        }

        // ===== 
        // ===== 
        // ===== 
        // ---- node helpers ----
        // ===== ' awe so cute, they help the node brains do their job '
        // ===== 
        // ===== 

        function updateColumnOptions(nodeId, headers) {
            const select = document.getElementById(`column_${nodeId}`);
            if (select) {
                // Store the currently selected value
                const currentValue = select.value;
                select.innerHTML = '<option value="">Select column...</option>';
                headers.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    if (header === currentValue) option.selected = true;
                    select.appendChild(option);
                });
            }
            // Also populate if aggregate or measurefilter controls exist
            const g = document.getElementById(`groupby_${nodeId}`);
            const m = document.getElementById(`measureCol_${nodeId}`);
            const mc = document.getElementById(`mcol_${nodeId}`);
            const rk = document.getElementById(`rankCol_${nodeId}`);
            const fr = document.getElementById(`frCol_${nodeId}`);
            // Pivot node dropdowns
            const prf = document.getElementById(`rowField_${nodeId}`);
            const pcf = document.getElementById(`columnField_${nodeId}`);
            const pvf = document.getElementById(`valueField_${nodeId}`);
            const fillSelect = (el) => {
                if (!el) return;
                const cv = el.value;
                el.innerHTML = '<option value="">Select column...</option>';
                headers.forEach(h => {
                    const op = document.createElement('option');
                    op.value = h;
                    op.textContent = h;
                    if (h === cv) op.selected = true;
                    el.appendChild(op);
                });
            };
            fillSelect(g);
            fillSelect(m);
            fillSelect(mc);
            fillSelect(rk);
            fillSelect(fr);
            fillSelect(prf);
            fillSelect(pcf);
            fillSelect(pvf);
        }

        function updateNormalizeConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            // Selected columns
            const columnCheckboxes = document.querySelectorAll(`input[name="column_${nodeId}"]:checked`);
            node.columns = Array.from(columnCheckboxes).map(cb => cb.value);
            // Flags
            const trimEl = document.getElementById(`trimEnds_${nodeId}`);
            const collapseEl = document.getElementById(`collapseSpaces_${nodeId}`);
            const removeSpecialEl = document.getElementById(`removeSpecial_${nodeId}`);
            const caseEl = document.getElementById(`caseMode_${nodeId}`);
            node.trimEnds = !!(trimEl && trimEl.checked);
            node.collapseSpaces = !!(collapseEl && collapseEl.checked);
            node.removeSpecial = !!(removeSpecialEl && removeSpecialEl.checked);
            node.caseMode = caseEl ? caseEl.value : 'none';
            // Refresh visual styles for readability
            refreshNormalizeCheckboxStyles(nodeId);
            // Trigger recompute if wired
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) { markDirty(nodeId); scheduleRecompute(); }
        }

        function updateNormalizeColumnOptions(nodeId, headers) {
            const columnContainer = document.getElementById(`columnSelection_${nodeId}`);
            if (columnContainer && headers && headers.length) {
                const node = nodes.find(n => n.id === nodeId) || {};
                const currentSelection = Array.isArray(node.columns) ? node.columns : [];
                columnContainer.innerHTML = `
                    <label class="column-select-header">
                        <input type="checkbox" id="selectAll_${nodeId}" onchange="toggleAllColumns('${nodeId}'); refreshNormalizeCheckboxStyles('${nodeId}')" style="margin-right:6px;"> Select All
                    </label>
                    ${headers.map(header => `
                        <label class=\"normalize-option ${currentSelection.includes(header) ? 'checked' : ''}\">
                            <input type=\"checkbox\" name=\"column_${nodeId}\" value=\"${header}\"
                                   ${currentSelection.includes(header) ? 'checked' : ''}
                                   onchange=\"updateNormalizeConfig('${nodeId}')\" style=\"margin-right:6px;\"> ${header}
                        </label>
                    `).join('')}
                `;
                // Apply color backgrounds immediately
                refreshNormalizeCheckboxStyles(nodeId);
            }
        }

        function refreshNormalizeCheckboxStyles(nodeId) {
            const labels = document.querySelectorAll(`#columnSelection_${nodeId} .normalize-option`);
            labels.forEach(label => {
                const cb = label.querySelector('input[type="checkbox"]');
                if (!cb) return;
                if (cb.checked) label.classList.add('checked');
                else label.classList.remove('checked');
            });
        }

        function updateCSVOutputConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const nameEl = document.getElementById(`csv_name_${nodeId}`);
            const hdrEl = document.getElementById(`csv_header_${nodeId}`);
            node.filename = (nameEl && nameEl.value) ? nameEl.value : (node.filename || 'output.csv');
            node.includeHeader = hdrEl ? !!hdrEl.checked : true;
        }

        function arrayToCSV(rows, headers, includeHeader = true) {
            const escape = (v) => {
                if (v === null || v === undefined) return '';
                const s = String(v);
                const needsQuote = s.includes(',') || s.includes('"') || s.includes('\n') || s.includes('\r');
                const escaped = s.replace(/"/g, '""');
                return needsQuote ? `"${escaped}"` : escaped;
            };
            const hdrs = Array.isArray(headers) && headers.length ? headers : (rows[0] ? Object.keys(rows[0]) : []);
            const lines = [];
            if (includeHeader && hdrs.length) lines.push(hdrs.map(escape).join(','));
            for (const r of rows) {
                lines.push(hdrs.map(h => escape(r[h])).join(','));
            }
            return lines.join('\n');
        }

        function triggerCSVExport(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const data = node.data || [];
            const headers = node.headers || [];
            const csv = arrayToCSV(data, headers, node.includeHeader !== false);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = node.filename && node.filename.trim() ? node.filename : 'data.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function updateJSONOutputConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const nameEl = document.getElementById(`json_name_${nodeId}`);
            node.filename = (nameEl && nameEl.value) ? nameEl.value : (node.filename || 'data.json');
        }

        function triggerJSONExport(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const json = JSON.stringify(node.data || [], null, 2);
            const blob = new Blob([json], { type: 'application/json;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = node.filename && node.filename.trim() ? node.filename : 'data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function updateExcelOutputConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const nameEl = document.getElementById(`excel_name_${nodeId}`);
            node.filename = (nameEl && nameEl.value) ? nameEl.value : (node.filename || 'data.xlsx');
        }

        function triggerExcelExport(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            if (!(window.XLSX && window.XLSX.utils && window.XLSX.write)) return;
            const rows = node.data || [];
            const ws = XLSX.utils.json_to_sheet(rows);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Data');
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = node.filename && node.filename.trim() ? node.filename : 'data.xlsx';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function updatePivotColumnOptions(nodeId, headers) {
            // Update regular dropdowns
            const columnField = document.getElementById(`columnField_${nodeId}`);
            const valueField = document.getElementById(`valueField_${nodeId}`);
            
            const fillSelect = (el) => {
                if (!el) return;
                const cv = el.value;
                el.innerHTML = '<option value="">Select column...</option>';
                headers.forEach(h => {
                    const op = document.createElement('option');
                    op.value = h;
                    op.textContent = h;
                    if (h === cv) op.selected = true;
                    el.appendChild(op);
                });
            };
            
            fillSelect(columnField);
            fillSelect(valueField);
            
            // Update row field checkboxes
            const rowFieldContainer = document.getElementById(`rowFieldSelection_${nodeId}`);
            if (rowFieldContainer && headers.length > 0) {
                const node = nodes.find(n => n.id === nodeId);
                const currentSelection = node.rowFields || [];
                
                rowFieldContainer.innerHTML = headers.map(header => `
                    <label style="display: block; margin: 2px 0; color: white;">
                        <input type="checkbox" name="rowField_${nodeId}" value="${header}" 
                               ${currentSelection.includes(header) ? 'checked' : ''}
                               onchange="updatePivotConfig('${nodeId}')"> ${header}
                    </label>
                `).join('');
            }
        }

        function updateAggregationConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            node.groupBy = (document.getElementById(`groupby_${nodeId}`) || {}).value || '';
            node.measureCol = (document.getElementById(`measureCol_${nodeId}`) || {}).value || '';
            node.measureOp = (document.getElementById(`measureOp_${nodeId}`) || {}).value || 'count';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        function updateMeasureFilterConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            node.column = (document.getElementById(`mcol_${nodeId}`) || {}).value || '';
            node.operator = (document.getElementById(`mop_${nodeId}`) || {}).value || '>';
            node.value = (document.getElementById(`mval_${nodeId}`) || {}).value || '';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        function updateJoinerConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            node.leftKey = (document.getElementById(`leftKey_${nodeId}`) || {}).value || '';
            node.rightKey = (document.getElementById(`rightKey_${nodeId}`) || {}).value || '';
            node.joinType = (document.getElementById(`joinType_${nodeId}`) || {}).value || 'inner';
            const inputs = connections.filter(c => c.to === nodeId && c.toType === 'input');
            if (inputs.length) {
                // Immediate recompute so preview updates right away
                const src = nodes.find(n => n.id === inputs[0].from);
                if (src && src.headers) {
                    processNodeData(node, src.data || [], src.headers || []);
                } else {
                    markDirty(nodeId);
                    scheduleRecompute();
                }
            }
        }

        function updateConstantConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            node.column = (document.getElementById(`constCol_${nodeId}`) || {}).value || 'const';
            node.value = (document.getElementById(`constVal_${nodeId}`) || {}).value || '';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                // Immediate recompute so preview updates right away
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.headers) {
                    processNodeData(node, inputNode.data || [], inputNode.headers || []);
                } else {
                    markDirty(nodeId);
                    scheduleRecompute();
                }
            }
        }

        function updateRankConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            node.column = (document.getElementById(`rankCol_${nodeId}`) || {}).value || '';
            node.order = (document.getElementById(`rankOrder_${nodeId}`) || {}).value || 'desc';
            node.outColumn = (document.getElementById(`rankOut_${nodeId}`) || {}).value || 'rank';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                // Immediate recompute so preview updates right away
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.headers) {
                    processNodeData(node, inputNode.data || [], inputNode.headers || []);
                } else {
                    markDirty(nodeId);
                    scheduleRecompute();
                }
            }
        }

        function updateFindReplaceConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            node.column = (document.getElementById(`frCol_${nodeId}`) || {}).value || '';
            node.pattern = (document.getElementById(`frFind_${nodeId}`) || {}).value || '';
            node.replacement = (document.getElementById(`frRepl_${nodeId}`) || {}).value || '';
            // New options
            node.caseSensitive = (document.getElementById(`frCase_${nodeId}`) || {}).checked || false;
            node.useRegex = (document.getElementById(`frRegex_${nodeId}`) || {}).checked || false;
            node.wholeCell = (document.getElementById(`frWhole_${nodeId}`) || {}).checked || false;
            node.replaceAll = (document.getElementById(`frAll_${nodeId}`) || {}).checked || false;
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                // Immediate recompute so preview updates right away
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.headers) {
                    processNodeData(node, inputNode.data || [], inputNode.headers || []);
                } else {
                    markDirty(nodeId);
                    scheduleRecompute();
                }
            }
        }

        function updateStringConcatConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            // Selected columns
            const checkboxes = document.querySelectorAll(`#columnSelection_${nodeId} input[name="column_${nodeId}"]`);
            node.columns = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
            // Other settings
            node.separator = (document.getElementById(`separator_${nodeId}`) || {}).value || '';
            node.outputColumn = (document.getElementById(`outputColumn_${nodeId}`) || {}).value || 'concatenated';
            node.keepOriginal = (document.getElementById(`keepOriginal_${nodeId}`) || {}).checked || false;
            // Update checkbox styles
            refreshStringConcatCheckboxStyles(nodeId);
            // Trigger recomputation if connected
            const inputConnection = inNeighbors.get(nodeId);
            if (inputConnection) { markDirty(nodeId); scheduleRecompute(); }
        }

        function updateStringConcatColumnOptions(nodeId, headers) {
            const columnContainer = document.getElementById(`columnSelection_${nodeId}`);
            if (columnContainer && headers && headers.length) {
                const node = nodes.find(n => n.id === nodeId) || {};
                const currentSelection = Array.isArray(node.columns) ? node.columns : [];
                columnContainer.innerHTML = `
                    <label class="column-select-header">
                        <input type="checkbox" id="selectAll_${nodeId}" onchange="toggleAllColumns('${nodeId}'); refreshStringConcatCheckboxStyles('${nodeId}')" style="margin-right:6px;"> Select All
                    </label>
                    ${headers.map(header => `
                        <label class="concat-option ${currentSelection.includes(header) ? 'checked' : ''}">
                            <input type="checkbox" name="column_${nodeId}" value="${header}"
                                   ${currentSelection.includes(header) ? 'checked' : ''}
                                   onchange="updateStringConcatConfig('${nodeId}')" style="margin-right:6px;"> ${header}
                        </label>
                    `).join('')}
                `;
                // Apply color backgrounds immediately
                refreshStringConcatCheckboxStyles(nodeId);
            }
        }

        function refreshStringConcatCheckboxStyles(nodeId) {
            const labels = document.querySelectorAll(`#columnSelection_${nodeId} .concat-option`);
            labels.forEach(label => {
                const cb = label.querySelector('input[type="checkbox"]');
                if (!cb) return;
                if (cb.checked) label.classList.add('checked');
                else label.classList.remove('checked');
            });
        }

        function updateStringSplitConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            // Selected columns
            const checkboxes = document.querySelectorAll(`#columnSelection_${nodeId} input[name="column_${nodeId}"]`);
            node.columns = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
            // Other settings
            node.delimiter = (document.getElementById(`delimiter_${nodeId}`) || {}).value || ',';
            node.maxSplits = parseInt((document.getElementById(`maxSplits_${nodeId}`) || {}).value) || 2;
            node.keepOriginal = (document.getElementById(`keepOriginal_${nodeId}`) || {}).checked || false;
            // Update checkbox styles
            refreshStringSplitCheckboxStyles(nodeId);
            // Trigger recomputation if connected
            const inputConnection = inNeighbors.get(nodeId);
            if (inputConnection) { markDirty(nodeId); scheduleRecompute(); }
        }

        function updateStringSplitColumnOptions(nodeId, headers) {
            const columnContainer = document.getElementById(`columnSelection_${nodeId}`);
            if (columnContainer && headers && headers.length) {
                const node = nodes.find(n => n.id === nodeId) || {};
                const currentSelection = Array.isArray(node.columns) ? node.columns : [];
                columnContainer.innerHTML = `
                    <label class="column-select-header">
                        <input type="checkbox" id="selectAll_${nodeId}" onchange="toggleAllColumns('${nodeId}'); refreshStringSplitCheckboxStyles('${nodeId}')" style="margin-right:6px;"> Select All
                    </label>
                    ${headers.map(header => `
                        <label class="split-option ${currentSelection.includes(header) ? 'checked' : ''}">
                            <input type="checkbox" name="column_${nodeId}" value="${header}"
                                   ${currentSelection.includes(header) ? 'checked' : ''}
                                   onchange="updateStringSplitConfig('${nodeId}')" style="margin-right:6px;"> ${header}
                        </label>
                    `).join('')}
                `;
                // Apply color backgrounds immediately
                refreshStringSplitCheckboxStyles(nodeId);
            }
        }

        function refreshStringSplitCheckboxStyles(nodeId) {
            const labels = document.querySelectorAll(`#columnSelection_${nodeId} .split-option`);
            labels.forEach(label => {
                const cb = label.querySelector('input[type="checkbox"]');
                if (!cb) return;
                if (cb.checked) label.classList.add('checked');
                else label.classList.remove('checked');
            });
        }

        function updateGitHubUrl(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            const urlInput = document.getElementById(`githubUrl_${nodeId}`);
            node.url = urlInput ? urlInput.value.trim() : '';

            // Debounced auto-fetch when URL present
            if (node._fetchTimer) { clearTimeout(node._fetchTimer); }
            if (node.url && !node.loading) {
                node._fetchTimer = setTimeout(() => {
                    // Re-check before firing
                    const latest = (document.getElementById(`githubUrl_${nodeId}`) || {}).value || '';
                    if (latest.trim() && !node.loading) {
                        fetchGitHubData(nodeId);
                    }
                }, 600);
            }
        }

        async function fetchGitHubData(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node || !node.url) {
                updateGitHubStatus(nodeId, 'Please enter a valid URL');
                return;
            }

            // Set loading state
            node.loading = true;
            updateGitHubUI(nodeId);
            updateGitHubStatus(nodeId, 'Fetching data...');

            try {
                const response = await fetch(node.url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const csvText = await response.text();
                
                // Parse CSV
                const lines = csvText.trim().split('\n');
                if (lines.length === 0) {
                    throw new Error('Empty CSV file');
                }
                
                // Parse headers
                const headers = parseCSVLine(lines[0]);
                
                // Parse data rows
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = parseCSVLine(lines[i]);
                    if (values.length > 0) {
                        const record = {};
                        headers.forEach((header, index) => {
                            record[header] = values[index] || '';
                        });
                        data.push(record);
                    }
                }
                
                // Update node
                node.data = data;
                node.headers = headers;
                node.loading = false;
                
                // Update UI
                updateGitHubUI(nodeId);
                updateGitHubStatus(nodeId, `Loaded ${data.length} rows, ${headers.length} columns`);
                updateNodePreview(nodeId, data.slice(0, 5), headers);
                
                // Trigger downstream updates
                markDirty(nodeId);
                scheduleRecompute();
                
            } catch (error) {
                node.loading = false;
                node.data = null;
                node.headers = [];
                updateGitHubUI(nodeId);
                updateGitHubStatus(nodeId, `Error: ${error.message}`);
                console.error('GitHub fetch error:', error);
            }
        }

        function updateGitHubUI(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            const fetchBtn = document.getElementById(`fetchBtn_${nodeId}`);
            if (fetchBtn) {
                fetchBtn.disabled = node.loading;
                fetchBtn.innerHTML = node.loading ? '⏳ Loading...' : '📥 Fetch Data';
            }
        }

        function updateGitHubStatus(nodeId, message) {
            const statusDiv = document.getElementById(`status_${nodeId}`);
            if (statusDiv) {
                statusDiv.textContent = message;
            }
        }

        // Simple CSV parser that handles quoted fields
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result;
        }

        function toggleStringConcatColumn(nodeId, column, checked) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            if (checked) {
                if (!node.columns.includes(column)) {
                    node.columns.push(column);
                }
            } else {
                node.columns = node.columns.filter(col => col !== column);
            }
            
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                // Immediate recompute so preview updates right away
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.headers) {
                    processNodeData(node, inputNode.data || [], inputNode.headers || []);
                } else {
                    markDirty(nodeId);
                    scheduleRecompute();
                }
            }
        }

        function updatePivotConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            // Get selected row fields from checkboxes
            const rowFieldCheckboxes = document.querySelectorAll(`input[name="rowField_${nodeId}"]:checked`);
            node.rowFields = Array.from(rowFieldCheckboxes).map(cb => cb.value);
            node.columnField = (document.getElementById(`columnField_${nodeId}`) || {}).value || '';
            node.valueField = (document.getElementById(`valueField_${nodeId}`) || {}).value || '';
            node.aggregation = (document.getElementById(`aggregation_${nodeId}`) || {}).value || 'count';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        function updateNullValueConfig(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            // Get selected columns from checkboxes
            const columnCheckboxes = document.querySelectorAll(`input[name="column_${nodeId}"]:checked`);
            node.columns = Array.from(columnCheckboxes).map(cb => cb.value);
            node.action = (document.getElementById(`action_${nodeId}`) || {}).value || 'remove';
            node.replaceValue = (document.getElementById(`replaceValue_${nodeId}`) || {}).value || '';
            
            // Show/hide replace value input based on action
            const replaceGroup = document.getElementById(`replaceValueGroup_${nodeId}`);
            if (replaceGroup) {
                replaceGroup.style.display = node.action === 'replace' ? 'block' : 'none';
            }
            
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        function updateNullValueColumnOptions(nodeId, headers) {
            const columnContainer = document.getElementById(`columnSelection_${nodeId}`);
            if (columnContainer && headers.length > 0) {
                const node = nodes.find(n => n.id === nodeId);
                const currentSelection = node.columns || [];
                
                columnContainer.innerHTML = `
                    <label style="display: block; margin: 2px 0; color: white; font-weight: bold;">
                        <input type="checkbox" id="selectAll_${nodeId}" onchange="toggleAllColumns('${nodeId}')"> Select All
                    </label>
                    ${headers.map(header => `
                        <label style="display: block; margin: 2px 0; color: white;">
                            <input type="checkbox" name="column_${nodeId}" value="${header}" 
                                   ${currentSelection.includes(header) ? 'checked' : ''}
                                   onchange="updateNullValueConfig('${nodeId}')"> ${header}
                        </label>
                    `).join('')}
                `;
            }
        }

        function toggleAllColumns(nodeId) {
            const selectAllCheckbox = document.getElementById(`selectAll_${nodeId}`);
            const columnCheckboxes = document.querySelectorAll(`input[name="column_${nodeId}"]`);
            
            columnCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateNullValueConfig(nodeId);
        }

        function toggleDataView(nodeId) {
            const node = document.getElementById(nodeId);
            const preview = document.getElementById(`preview_${nodeId}`);
            const isDataOnly = node.classList.contains('data-only');
            
            if (isDataOnly) {
                // Show full node
                node.classList.remove('data-only');
                node.querySelector('.node-header').style.display = '';
                node.querySelector('.node-content > div:first-child').style.display = '';
                node.querySelector('.node-settings').style.display = '';
            } else {
                // Show only data preview - hide other elements but keep in same container
                node.classList.add('data-only');
                node.querySelector('.node-header').style.display = 'none';
                node.querySelector('.node-content > div:first-child').style.display = 'none';
                node.querySelector('.node-settings').style.display = 'none';
            }
            updateConnections();
        }

        function renderSortCriteria(nodeId, headers = []) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const wrap = document.getElementById(`sortCriteria_${nodeId}`);
            if (!wrap) return;
            const hdrs = Array.isArray(headers) && headers.length ? headers : (node.headers || []);
            const optionsHTML = (sel) => {
                const cur = sel || '';
                return ['<option value="">Select column...</option>'].concat(
                    hdrs.map(h => `<option value="${h}" ${h===cur?'selected':''}>${h}</option>`)
                ).join('');
            };
            wrap.innerHTML = node.sorts.map((s, idx) => `
                <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                    <select class="setting-select" id="sortCol_${node.id}_${idx}" onchange="updateSortCriterion('${node.id}', ${idx}, 'column', this.value)">
                        ${optionsHTML(s.column)}
                    </select>
                    <select class="setting-select" id="sortType_${node.id}_${idx}" style="max-width:130px;" onchange="updateSortCriterion('${node.id}', ${idx}, 'type', this.value)">
                        <option value="alpha" ${s.type==='alpha'?'selected':''}>alphabetic</option>
                        <option value="numeric" ${s.type==='numeric'?'selected':''}>numeric</option>
                        <option value="date" ${s.type==='date'?'selected':''}>date</option>
                    </select>
                    <select class="setting-select" id="sortOrder_${node.id}_${idx}" style="max-width:110px;" onchange="updateSortCriterion('${node.id}', ${idx}, 'order', this.value)">
                        <option value="asc" ${s.order==='asc'?'selected':''}>asc</option>
                        <option value="desc" ${s.order==='desc'?'selected':''}>desc</option>
                    </select>
                    <button class="node-expand" style="background:#ef4444; color:white;" onclick="event.stopPropagation(); removeSortCriterion('${node.id}', ${idx})">➖</button>
                </div>
            `).join('');
        }

        function addSortCriterion(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node.sorts.push({ column: '', type: 'alpha', order: 'asc' });
            renderSortCriteria(nodeId);
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) { markDirty(nodeId); scheduleRecompute(); }
        }

        function removeSortCriterion(nodeId, idx) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node.sorts.splice(idx, 1);
            if (node.sorts.length === 0) node.sorts.push({ column: '', type: 'alpha', order: 'asc' });
            renderSortCriteria(nodeId);
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) { markDirty(nodeId); scheduleRecompute(); }
        }

        function updateSortCriterion(nodeId, idx, field, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            if (!node.sorts[idx]) return;
            node.sorts[idx][field] = value;
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.headers) {
                    processNodeData(node, inputNode.data || [], inputNode.headers || []);
                } else {
                    markDirty(nodeId);
                    scheduleRecompute();
                }
            }
        }

        function reprocessColumnRenamer(nodeId) {
            const inputConnection = connections.find(conn => 
                conn.to === nodeId && conn.toType === 'input'
            );
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.headers) {
                    processNodeData(nodes.find(n => n.id === nodeId), inputNode.data || [], inputNode.headers || []);
                } else {
                    markDirty(nodeId);
                    scheduleRecompute();
                }
            }
        }

        // Toggle Union remove-duplicates and recompute
        function setUnionDedup(nodeId, checked) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node.removeDuplicates = !!checked;
            // Union depends on multiple inputs; mark dirty and schedule recompute
            markDirty(nodeId);
            scheduleRecompute();
        }

        function renderManualTable(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            const wrap = document.getElementById(`manual_${nodeId}`);
            if (!node || !wrap) return;
            const headerInputs = node.headers.map((h, idx) => `
                <th><input type="text" class="setting-input" style="padding:4px 6px;" value="${h}"
                    onchange="updateManualHeader('${nodeId}', ${idx}, this.value)"></th>
            `).join('');
            const rowInputs = node.headers.map((h, idx) => `
                <td><input type="text" class="setting-input" style="padding:4px 6px;" value="${node.data[0][h] || ''}"
                    onchange="updateManualCell('${nodeId}', 0, ${idx}, this.value)"></td>
            `).join('');
            wrap.innerHTML = `
                <table class="preview-table" style="background: rgba(255,255,255,0.1);">
                    <thead><tr>${headerInputs}</tr></thead>
                    <tbody>
                        ${node.data.map((row, rIdx) => `
                            <tr>
                                ${node.headers.map((h, cIdx) => `
                                    <td><input type=\"text\" class=\"setting-input\" style=\"padding:4px 6px;\" value=\"${row[h] || ''}\"
                                        onchange=\"updateManualCell('${nodeId}', ${rIdx}, ${cIdx}, this.value)\"></td>
                                `).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function addManualRow(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const newRow = {};
            node.headers.forEach(h => newRow[h] = '');
            node.data.push(newRow);
            renderManualTable(nodeId);
            updateNodePreview(nodeId, node.data.slice(0,5), node.headers);
            markDirty(nodeId);
            scheduleRecompute();
        }

        function deleteManualRow(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            if (node.data.length > 1) {
                node.data.pop();
                renderManualTable(nodeId);
                updateNodePreview(nodeId, node.data.slice(0,5), node.headers);
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        function updateManualCell(nodeId, rowIdx, colIdx, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const col = node.headers[colIdx];
            if (typeof node.data[rowIdx] === 'undefined') return;
            node.data[rowIdx][col] = value;
            updateNodePreview(nodeId, node.data.slice(0,5), node.headers);
            markDirty(nodeId);
            scheduleRecompute();
        }

        function updateManualHeader(nodeId, colIdx, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const old = node.headers[colIdx];
            const newName = value.trim() || old;
            if (newName !== old) {
                node.headers[colIdx] = newName;
                node.data.forEach(r => { r[newName] = r[old]; delete r[old]; });
                renderManualTable(nodeId);
                updateNodePreview(nodeId, node.data.slice(0,5), node.headers);
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        function updateFilterPattern(nodeId, pattern) {
            const node = nodes.find(n => n.id === nodeId);
            node.pattern = pattern;
            
            // Find input data from connected nodes
            const inputConnection = connections.find(conn => 
                conn.to === nodeId && conn.toType === 'input'
            );
            
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function toggleAnyFilterOption(nodeId, key, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node[key] = value;
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function setAnyFilterMode(nodeId, mode) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node.mode = mode === 'remove' ? 'remove' : 'keep';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function setMeasureFilterMode(nodeId, mode) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node.mode = mode === 'remove' ? 'remove' : 'keep';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function updateColumnFilter(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            const select = document.getElementById(`column_${nodeId}`);
            node.column = select.value;
            
            // Reprocess data if we have input
            const inputConnection = connections.find(conn => 
                conn.to === nodeId && conn.toType === 'input'
            );
            
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function updateColumnFilterPattern(nodeId, pattern) {
            const node = nodes.find(n => n.id === nodeId);
            node.pattern = pattern;
            
            // Reprocess data if we have input
            const inputConnection = connections.find(conn => 
                conn.to === nodeId && conn.toType === 'input'
            );
            
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function updateWildHeadersPattern(nodeId, pattern) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node.pattern = pattern;
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function toggleWildHeadersOption(nodeId, key, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node[key] = value;
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function setColumnFilterMode(nodeId, mode) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node.mode = mode === 'remove' ? 'remove' : 'keep';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function toggleColumnFilterOption(nodeId, key, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node[key] = value;
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }
        /// nick name; wild head
        function setWildHeadersMode(nodeId, mode) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            node.mode = mode === 'remove' ? 'remove' : 'keep';
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                const inputNode = nodes.find(n => n.id === inputConnection.from);
                if (inputNode && inputNode.data) {
                    processNodeData(node, inputNode.data, inputNode.headers);
                }
            }
        }

        function updateCSVRowRemoval(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            const removeTop = parseInt(document.getElementById(`removeTop_${nodeId}`).value) || 0;
            const removeBottom = parseInt(document.getElementById(`removeBottom_${nodeId}`).value) || 0;
            
            node.removeTop = removeTop;
            node.removeBottom = removeBottom;
            
            // Reprocess the CSV data if it exists
            if (node.data) {
                processCSVData(node);
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        function processCSVData(node) {
            if (!node.data || !node.data.length) return;
            
            let processedData = [...node.data];
            
            // Remove rows from top
            if (node.removeTop > 0) {
                processedData = processedData.slice(node.removeTop);
            }
            
            // Remove rows from bottom
            if (node.removeBottom > 0) {
                processedData = processedData.slice(0, -node.removeBottom);
            }
            
            // Update the node's processed data for propagation
            node.data = processedData;
            updateNodePreview(node.id, processedData.slice(0, 5), node.headers);
        }

        function updateColumnRenamerConfig(nodeId, headers) {
            const opsDiv = document.getElementById(`columnOps_${nodeId}`);
            if (!opsDiv || !headers.length) return;
            
            const node = nodes.find(n => n.id === nodeId);
            
            opsDiv.innerHTML = headers.map((header, index) => `
                <div style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center;">
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <button onclick="moveColumn('${nodeId}', ${index}, -1)" style="width: 20px; height: 16px; font-size: 10px; padding: 0;" ${index === 0 ? 'disabled' : ''}>↑</button>
                        <button onclick="moveColumn('${nodeId}', ${index}, 1)" style="width: 20px; height: 16px; font-size: 10px; padding: 0;" ${index === headers.length - 1 ? 'disabled' : ''}>↓</button>
                    </div>
                    <input type="checkbox" title="Hide this column from output" onchange="toggleColumnRemoval('${nodeId}', '${header}', this.checked)" 
                           ${node.removals.includes(header) ? 'checked' : ''}>
                    <span style="min-width: 80px; font-size: 0.85rem; color: white;">${header}</span>
                    <span style="color: #ccc;">→</span>
                    <input type="text" class="setting-input" placeholder="${header}" 
                           value="${node.renames[header] || header}" 
                           onchange="updateColumnRename('${nodeId}', '${header}', this.value)"
                           style="flex: 1; padding: 4px 8px;">
                </div>
            `).join('');
        }

        function toggleColumnRemoval(nodeId, column, remove) {
            const node = nodes.find(n => n.id === nodeId);
            if (remove) {
                if (!node.removals.includes(column)) {
                    node.removals.push(column);
                }
            } else {
                node.removals = node.removals.filter(col => col !== column);
            }
            reprocessColumnRenamer(nodeId);
        }

        function moveColumn(nodeId, index, direction) {
            const node = nodes.find(n => n.id === nodeId);
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (!inputConnection) return;
            
            const inputNode = nodes.find(n => n.id === inputConnection.from);
            if (!inputNode || !inputNode.headers) return;
            
            // Use the current column order if it exists, otherwise use input headers
            let headers;
            if (node.columnOrder.length > 0) {
                headers = [...node.columnOrder];
            } else {
                headers = [...inputNode.headers];
            }
            
            const newIndex = index + direction;
            
            if (newIndex < 0 || newIndex >= headers.length) return;
            
            // Track the column being moved for highlighting
            const movedColumn = headers[index];
            const finalColumnName = node.renames[movedColumn] || movedColumn;
            
            // Initialize movedColumns array if it doesn't exist
            if (!node.movedColumns) {
                node.movedColumns = [];
            }
            
            // Add to moved columns list if not already there
            if (!node.movedColumns.includes(finalColumnName)) {
                node.movedColumns.push(finalColumnName);
            }
            
            // Swap headers
            [headers[index], headers[newIndex]] = [headers[newIndex], headers[index]];
            node.columnOrder = headers;
            
            updateColumnRenamerConfig(nodeId, headers);
            markDirty(nodeId);
            scheduleRecompute();
        }

        function updateColumnRename(nodeId, oldName, newName) {
            const node = nodes.find(n => n.id === nodeId);
            if (newName && newName !== oldName) {
                node.renames[oldName] = newName;
            } else {
                delete node.renames[oldName];
            }
            const inputConnection = connections.find(conn => conn.to === nodeId && conn.toType === 'input');
            if (inputConnection) {
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        function reprocessColumnRenamer(nodeId) {
            const inputConnection = connections.find(conn => 
                conn.to === nodeId && conn.toType === 'input'
            );
            
            if (inputConnection) {
                markDirty(nodeId);
                scheduleRecompute();
            }
        }

        // Initialize canvas
        window.addEventListener('resize', updateConnections);
        
        // Create initial CSV node
        createCSVNode();
    </script>
</body>
</html>
